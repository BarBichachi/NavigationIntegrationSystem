// ---------------------------------------------------------
// GENERATED: 2026-02-08 12:00:02
// PROJECT: NavigationIntegrationSystem (WinUI 3 / C#)
// ---------------------------------------------------------


// ---------------------------------------------------------
// FILE: .\PROJECT_STATE.md
// ---------------------------------------------------------

# NavigationIntegrationSystem – PROJECT_STATE

# File Listing Powershell Command
```powershell
Get-ChildItem -Recurse -Force |
  Where-Object { $_.FullName -notmatch '\\(\.git|\.vs|bin|obj|PublishProfiles|Assets)(\\|$)' } |
  ForEach-Object { Resolve-Path -LiteralPath $_.FullName -Relative }
```

# Overview
NavigationIntegrationSystem (NIS) is a standalone WinUI 3 desktop application (net8.0-windows) designed to integrate, manage, and visualize INS devices.
The project is intended to be embedded later as a standalone project inside a larger solution (e.g. under a Utils folder), without runtime coupling to other projects.

The solution is structured as a clean, layered monorepo with strict separation of responsibilities.

# Architecture (Locked)

## Layered Solution Structure
```
src/
  NavigationIntegrationSystem.Core
  NavigationIntegrationSystem.Devices
  NavigationIntegrationSystem.Infrastructure
  NavigationIntegrationSystem.UI
```

Dependency direction is strictly one-way:
```
UI -> Devices -> Core
UI -> Infrastructure -> Core
```

---

# Key Files Reference

## Core Contracts
- IInsDevice: `src/NavigationIntegrationSystem.Core/Devices/IInsDevice.cs`
- ILogService: `src/NavigationIntegrationSystem.Core/Logging/ILogService.cs`

## Device Registration
- Device registration entry point: `src/NavigationIntegrationSystem.Devices/Runtime/DevicesModuleBootstrapper.cs`
- Device registry: `src/NavigationIntegrationSystem.Devices/Runtime/InsDeviceRegistry.cs`
- Device base class: `src/NavigationIntegrationSystem.Devices/Runtime/InsDeviceBase.cs`

## MVVM Base
- ViewModelBase: `src/NavigationIntegrationSystem.UI/ViewModels/Base/ViewModelBase.cs`

## DI Bootstrap
- HostBuilderFactory: `src/NavigationIntegrationSystem.UI/Bootstrap/HostBuilderFactory.cs`

## Infrastructure Services
- FileLogService: `src/NavigationIntegrationSystem.Infrastructure/Logging/FileLogService.cs`
- DevicesConfigService: `src/NavigationIntegrationSystem.Infrastructure/Persistence/DevicesConfig/DevicesConfigService.cs`

---

# Coding Conventions (Locked)

## General Principles
- Prefer clever, elegant solutions when they improve clarity and power
- Strongly prefer well-engineered, explicit architecture
- Architecture quality is a feature, not overhead
- Changes to existing structure are welcome when they improve design
- Refactoring may introduce new patterns or abstractions when justified
- Favor long-term maintainability over short-term convenience

## Naming

### C#
- Classes / Types: `PascalCase`
- Properties: `PascalCase`
- Private fields (non-properties): `m_PascalCase`
- Method parameters: `i_PascalCase`
- Local variables: `camelCase`
- Enums and enum values: `PascalCase`

### MVVM
- ViewModels: `[Feature]ViewModel`
- Commands: `[Action]Command` (e.g. `LoginCommand`, `ApplyToAllCommand`)
- Services: `[Purpose]Service`
- Pages / Views: `[Feature]Page`, `[Feature]View`

## Class Structure
- Every class must be organized using `#region` blocks
- Preferred region order:
  1. `Properties`
  2. `Private Fields`
  3. `Commands`
  4. `Constructors`
  5. `Functions`
  6. `Event Handlers`
- Functions should be short and focused
- Complex logic must be decomposed into sub-functions
- Prefer composable and testable units over monolithic logic

## Comments
- One-line `//` comment above every function
- Do not use XML `<summary>` comments
- Do not add comments on properties
- No trailing period at the end of comment lines
- Inline comments are allowed when logic is non-trivial or clever

## Properties
- Prefer one-line get/set property syntax:
  ```csharp
  public string DeviceId { get => m_DeviceId; set => SetProperty(ref m_DeviceId, value); }
  ```

## Commands (WinUI / MVVM)
- Commands must be declared explicitly as properties (no prefix, like regular properties)
- Commands belong under `#region Commands`
- Prefer explicit command interfaces (`IAsyncRelayCommand` / `IRelayCommand`)
- Do not use `[RelayCommand]` attributes
- Even simple or synchronous commands should be explicit

## Control Flow
- Braces are mandatory for all control blocks (`if`, `for`, `foreach`, `while`)
- Readability and predictability take precedence over brevity

## Async/Threading
- **Infrastructure/Devices**: Always use `ConfigureAwait(false)` (no UI context needed)
- **UI/ViewModels**: Never use `ConfigureAwait` (needs DispatcherQueue context)
- UI updates from non-UI code: always marshal via `DispatcherQueue.TryEnqueue()`

## Namespaces & Usings
- Always use `using` directives
- Avoid fully-qualified type names
- Keep namespace boundaries intentional and meaningful

## XAML Formatting
- Prefer single-line elements whenever possible
- Use multi-line formatting only when width or readability requires it
- Avoid unnecessary line breaks

## XAML Layout Structure (Critical for Hot Reload)
- Always prefer explicit `Grid` usage
- Always declare `Grid.RowDefinitions` and `Grid.ColumnDefinitions` explicitly
- Never define row or column definitions inline on the Grid tag
- This is required to ensure Hot Reload behaves correctly

## XAML Comments
- Comments inside XAML are allowed and encouraged
- Use XAML comments to explain layout intent or structural decisions
- Avoid comments that restate obvious XAML behavior

## Resources & Styling
- Converters must be registered globally in `App.xaml`
- Shared styles and resources are preferred over per-page definitions
- Maintain a consistent visual language across the application

## Refactoring Rules
- Show only added / removed / updated parts when refactoring
- Existing structure may be changed when there is a clear reason
- New architectural suggestions are welcome when they improve design quality
- Prefer improving abstractions over preserving legacy structure

---

# External Dependencies

## All Projects
- Microsoft.Extensions.DependencyInjection: v10.0.2
- Microsoft.Extensions.Hosting: v10.0.2
- Microsoft.Extensions.Logging: v10.0.2

## UI Project
- Microsoft.WindowsAppSDK: v1.8.260101001
- Microsoft.Windows.SDK.BuildTools: v10.0.26100.7463
- CommunityToolkit.Mvvm: v8.4.0 (interfaces only - no source generators)
- CommunityToolkit.WinUI.Collections: v8.2.251219
- System.Text.Json (implicit via .NET 8)

## Notes
- CommunityToolkit.Mvvm is referenced only for interfaces (`IAsyncRelayCommand`, `IRelayCommand`)
- No source generators (`[ObservableProperty]`, `[RelayCommand]`) are used
- All MVVM is implemented manually

---

# Project Layer Details

## NavigationIntegrationSystem.Core
**Purpose:**
Pure domain and contracts layer.
Contains no UI code, no file I/O, no WinUI/Windows dependencies.

**Responsibilities:**
- Domain enums (e.g. `DeviceType`, `DeviceStatus`)
- Core device contracts (`IInsDevice`, device interfaces)
- Domain models (`DeviceDefinition`, `DeviceFieldDefinition`, etc.)
- Logging contracts (`ILogService`, `LogRecord`, `LogLevel`, `ILogPaths`)
- Any interfaces intended to be implemented by Infrastructure or Devices

**Rules:**
- No references to WinUI, Windows App SDK, file system, or concrete implementations
- Core is stable and changes rarely

---

## NavigationIntegrationSystem.Devices
**Purpose:**
All INS device-specific logic lives here.
Adding a new INS device should only require changes inside this project.

**Responsibilities:**
- INS device implementations (e.g. `Vn310InsDevice`, `Tmaps100XInsDevice`, `ManualInsDevice`)
- Device modules (`IInsDeviceModule` implementations)
- Device runtime registry and lifecycle management
- Device catalog / device metadata
- Device connection configuration models (UDP/TCP/Serial)
- Explicit device registration

**Device Registration Model (Locked):**
- Devices are registered explicitly (no reflection-based auto-discovery)
- There is a single registration entry point inside Devices
- UI/Bootstrap calls a single method to register all devices
- HostBuilderFactory is never modified when adding new devices

**Adding a new device conceptually involves:**
1. Add a new `DeviceType` value in Core
2. Add a new `InsDevice` implementation in Devices
3. Add a new `DeviceModule` implementation in Devices
4. Register the module in the Devices registration entry point

---

## NavigationIntegrationSystem.Infrastructure
**Purpose:**
Concrete implementations of Core contracts.

**Responsibilities:**
- File-based logging (`FileLogService`)
- Path resolution and application paths
- Application and logging settings
- Persistence of device configuration (files, JSON, etc.)
- Binary data recording (matching existing RecordDecoderPro format)

**Rules:**
- Implements Core interfaces only
- Owns file formats, paths, serialization
- UI never accesses files directly

---

## NavigationIntegrationSystem.UI
**Purpose:**
WinUI 3 presentation layer.

**Responsibilities:**
- Views (Pages, Panes)
- ViewModels (MVVM)
- UI-only services (navigation, dialogs, UI log buffer)
- Value converters
- Application bootstrap and DI wiring

**MVVM Rules (Locked):**
- No CommunityToolkit MVVM source generators
- No `[ObservableProperty]` / `[RelayCommand]` generators
- Manual MVVM implementation using a shared `ViewModelBase`
- `ViewModelBase` implements `INotifyPropertyChanged` with `SetProperty`
- Commands implemented via explicit `ICommand` implementations
- ViewModels contain UI logic only, no device-specific logic

**UI Foldering Standard (Type-first):**
```
Enums/
Interfaces/
Services/
Converters/
ViewModels/
Views/
Navigation/
Bootstrap/
Resources/
```

Subfolders may be used inside type folders for domain clarity

---

## Commands Architecture (Locked)
- Explicit `ICommand` implementations owned by UI
- No dependency on toolkit generators
- ICommand-based, explicit, debuggable, framework-agnostic
- Suitable for reuse in legacy .NET projects

---

## Target Frameworks
- NavigationIntegrationSystem.UI: `net8.0-windows10.0.19041.0`
- Other projects: compatible with `net8.0` / `net8.0-windows` as required
- Solution is a container only; project configuration defines behavior

---

# Device Implementations (Current)

## Real Devices
1. **VN310** (`DeviceType.Vn310`)
   - Module: `Vn310DeviceModule`
   - Implementation: `Vn310InsDevice`
   - Connection: Not yet implemented

2. **TMAPS100X** (`DeviceType.Tmaps100X`)
   - Module: `Tmaps100XDeviceModule`
   - Implementation: `Tmaps100XInsDevice`
   - Connection: Not yet implemented

## Virtual Devices
3. **Manual** (`DeviceType.Manual`)
   - Module: `ManualDeviceModule`
   - Implementation: `ManualInsDevice`
   - No connection settings, no Inspect pane

---

# Integration Parameters (Current)

**Grid Rows (in order):**
1. Azimuth
2. Elevation
3. Latitude
4. Longitude
5. Altitude
6. Pitch
7. Roll
8. Speed

**Each row has:**
- Parameter name column
- Integrated Output column
- One input candidate column per connected device
- Manual input option (RadioButton + TextBox)

**Note:** These parameters are current and may evolve.

---

# Binary Recording Format (Locked)

## Overview
NIS uses binary `.dat` file recording to match the existing RecordDecoderPro tool format from the larger system.

## Standard Binary Record Structure
Based on the existing `BinaryFileRecorderEnhanced` pattern:

```
[SyncWord: 2 bytes (ushort)]
[ID: 2 bytes (ushort)]
[DataLength: 2 bytes (ushort)]
[Time: 8 bytes (long - DateTime.ToBinary())]
[DataType: 2 bytes (ushort)]
[Raw data bytes: DataLength bytes]
```

## Recording Service
- Integration recording will use a singleton instance of `BinaryFileRecorderEnhanced`
- Follows existing Infrastructure patterns
- Compatible with RecordDecoderPro tooling

---

# Current State (Implemented)

## Integration Page (UI locked + working)
- Integration grid exists and is functional:
  - Rows: Azimuth, Elevation, Latitude, Longitude, Altitude, Pitch, Roll, Speed (dummy for now)
  - Columns: Parameter, Integrated Output, per-device inputs
- Connected devices appear in the header as "Active Sources":
  - Each device has:
    - Visibility toggle (show/hide its inputs across all rows)
    - "Apply to All" (select this device as the source for all rows)
- Manual source supported:
  - Manual appears as a virtual device
  - Manual input uses a RadioButton + TextBox per row
  - TextBox enabled only when selected
- Live dummy updates:
  - Candidate values update via DispatcherQueueTimer (250ms)
  - Integrated output reflects the currently selected candidate per row

## Devices / Connection interaction
- Integration listens to device Status changes:
  - Rebuilds ConnectedDevices header list
  - Rebuilds per-row Sources
  - Refreshes VisibleSources based on header toggles
- Selection survives device rebuilds by re-selecting by DeviceType when possible
- Real devices:
  - Connect/Disconnect button + Inspect/Settings panes
- Manual device:
  - Has Connect/Disconnect only

## Logs Page (Locked)
- Search, filters, copy, delete, select

---

# Next Steps

## 1) Record inputs + outputs to a single file (MVP)
- Create a recorder service in Infrastructure that:
  - Uses singleton `BinaryFileRecorderEnhanced` pattern
  - Writes binary `.dat` format matching RecordDecoderPro
- Start/Stop recording controls on the top of the software (always visible)
- Compatible with existing RecordDecoderPro tool

## 2) "Recorded file" as a virtual INS source
- Add a new virtual source option "File"
- Treat file playback exactly like a device source:
  - Appears in Active Sources
  - Appears per-row as a selectable candidate
- Provide:
  - Load file action
  - Basic playback controls (play, pause, seek)
  - Playback speed control
- Provide "Download template file" action with example rows

## 3) Make integration real (replace dummy tick)
- Replace Tick() random deltas with real device telemetry
- Devices publish field updates
- Candidate values update from live streams
- UI updates marshaled via DispatcherQueue
- Preserve existing selection, visibility, and fallback behavior


---

# Integrated INS Output Recording (DataRecordType = 50) — LOCKED

## Purpose
Add a unified “Integrated INS Output” binary record that represents the **final integrated output per field**, 
while preserving full source traceability. The record must be fully compatible with the existing RecordDecoderPro
tool **without modifying its core logic**.

This is achieved by introducing a new `DataRecordType`, a dedicated binary payload + comm frame, and a RecordDecoderPro Item template.

---

## Record Type (Locked)
- `Infrastructure.Enums.DataRecordType.IntegratedInsOutputRawData = 50`
- RecordDecoderPro handles it via a new Item:
- case DataRecordType.IntegratedInsOutputRawData: IntegratedInsOutputItem.InitializeDict(header, rawData); break;

---

## Integrated Fields (Final Order — Locked)

The following order is final and must not change:

1. **Output Time**
 - OutputTime[hms]
 - OutputTime[sec]

2. **Position**
 - Latitude
 - Longitude
 - Altitude

3. **Euler Angles**
 - Roll
 - Pitch
 - Azimuth
 - Roll Rate
 - Pitch Rate
 - Azimuth Rate

4. **Velocity**
 - Velocity (total)
 - Velocity North
 - Velocity East
 - Velocity Down

5. **Status**
 - StatusValue (bitmask)

6. **Course**

---

## Time Convention (Locked)

### Record Receive Time
- Comes from `header.Time`
- Stored as `DateTime.ToBinary()` (`long`)
- Decoded exactly like other items:
- `DateTime.FromBinary(header.Time)`
- CSV columns:
  - `RcvTime[hms]`
  - `RcvTime[sec]`

### Output Time
- Stored inside the payload as `DateTime.ToBinary()` (`long`)
- Decoded the same way as other device times (e.g. `TmapsTime`)
- CSV columns:
- `OutputTime[hms]`
- `OutputTime[sec]`

---

## Per-Field Source Triplet (Locked)

Each integrated field is represented by **three columns**:

- `[FieldName]Device` -> `ushort` (DeviceCode enum value)
- `[FieldName]Id`     -> `ushort` (device instance index per DeviceCode)
- `[FieldName]Value`  -> `double`

This applies to **all numeric fields**.

Example: LatitudeDevice, LatitudeId, LatitudeValue


---

## Binary Types (Locked)

| Field            | Type     |
|------------------|----------|
| DeviceCode       | ushort   |
| DeviceId         | ushort   |
| Value            | double   |
| OutputTimeBinary | long     |
| StatusValue      | uint     |

---

## Status Model (Locked)

- All vendor-specific INS statuses are normalized into a **single `StatusValue` bitmask**
- Defined in `IntegratedInsOutputStatusFlags`
- Mapping from VN310 / Tmaps / StandardIns happens **outside** RecordDecoderPro
- Bit allocation is documented in code comments and treated as locked once committed

---

## Header.ID (Locked)
- `header.ID` for integrated output is always `0`, for devices of the same type, increment by one starting from 0
- Per-field source identity is represented by `(DeviceCode, DeviceId)`
- No reliance on `header.ID` for source tracking

---

## Implemented Files (Current State)

The following files were created and currently live under `Temp/` (to be moved later):

- `IntegratedInsOutput_Data.cs`
- `IntegratedInsOutput_CommFrame.cs`
- `IntegratedInsOutputStatusFlags.cs`
- `IntegratedInsOutputItem.cs`

### Responsibilities
- **_Data**: Pure payload model (similar to `VN310_InsData`, `Tmaps100_InsData`)
- **_CommFrame**: Binary encode/decode wrapper (similar to `StdInsCommFrame`)
- **StatusFlags**: Unified status bitmask definition
- **Item**: RecordDecoderPro CSV mapping + column naming

---

## What’s Left To Do (For End-to-End Functionality)

### 1. Finalize Binary Layout
- Lock exact write/read order inside `IntegratedInsOutput_CommFrame`
- Ensure `EncodeBinaryData` and `DecodeBinaryData` are perfectly symmetric

### 2. Finalize RecordDecoderPro Item
- Ensure column list matches locked field order
- Decode:
  - `RcvTime` from `header.Time`
  - `OutputTime` from payload
- Emit 3 columns per field consistently

### 3. Move Files Out of Temp
- Infrastructure files -> proper `Infrastructure.Navigation...` namespaces
- Item file -> `RecordDecoderPro.ItemTemplates`

### 4. Recording Side (NIS / Infrastructure)
- Build `IntegratedInsOutput_Data` from selected per-row sources
- Assign `DeviceCode` + `DeviceId` per field
- Populate `OutputTime` based on selected source
- Populate `StatusValue`
- Write record using:
  - `DataType = 50`
  - `Time = DateTime.UtcNow.ToBinary()`

### 5. Device Instance Indexing
- Maintain per-DeviceType instance counters
- Stable IDs per session
- Used consistently across integrated fields

### 6. Mapping Logic (Later Phase)
- Per-field source selection
- “Apply to All” behavior
- Manual device numeric input
- Vendor-specific status -> unified status bitmask mapping

---

## Stop Point
At this point:
- Schema is fully locked
- Binary contract shape is defined
- Decoder strategy is aligned with existing tooling
- Files exist but are not yet wired end-to-end

Next continuation starts with:
**validating the binary layout and wiring encode -> record -> decode -> CSV**

# NavigationIntegrationSystem – PROJECT_STATE (Update – 2026-02-05)

# Summary of what we decided today (stop point)

## VelocityTotal policy (UPDATED)
- VelocityTotal is **not taken directly from a device** in our integration UI
- VelocityTotal is **calculated from the selected Velocity North/East/Down** values
- Recorder will still **store VelocityTotal as its own field** in the IntegratedInsOutput record (DataRecordType=50)
- UI must indicate this clearly (e.g. "Velocity Total (calc)" or similar)

## IntegratedInsOutputItem column order bug (FIX REQUIRED)
- In `IntegratedInsOutputItem.Process()` the OutputTime columns were added in the wrong order
- Required order is **DeviceCode, DeviceId, then Value** (for time: hms + sec)
- Fix required inside `IntegratedInsOutputItem.Process()`:
  - Add `OutputTimeDeviceCode`
  - Add `OutputTimeDeviceId`
  - Add `OutputTime[hms]`
  - Add `OutputTime[sec]`
- Note: This is still in TEMP and not yet part of the big solution, so we are free to change it now without breaking anything

## “TEMP IntegratedInsOutput files” status (UPDATED CLARIFICATION)
- The 4 integrated-output files currently live at repo root / TEMP area only to define the contract and decoding behavior
- They are **not yet integrated into the big solution**
- We can still adapt naming, ordering, properties, and the decoder mapping now
- NIS will implement a recorder that outputs a `.dat` file compatible with RecordDecoderPro

## Recording infrastructure in NIS (UPDATED)
- We added a temporary copy of `DataRecordHeader` inside NIS:
  - `NavigationIntegrationSystem.Infrastructure.Recording.DataRecordHeader`
  - SyncWord = `0x7E55`
  - Header layout matches RecordDecoderPro expectations
- This file is explicitly temporary; when NIS is embedded into the big solution, we will delete/replace it and fix usings

## “Record everything” requirement (UPDATED)
- Recorder must record:
  1) **All raw device telemetry** (everything a device provides), even if not shown in Integration UI
  2) **Integrated output record** (DataRecordType=50) containing only the final integrated fields (below)

## Final integrated output rows list (LOCKED FOR RECORDER MAPPING)
The integrated output fields (and UI integration rows) are exactly the ones represented by `IntegratedInsOutput_Data`:

1) Output Time
2) Position: Latitude, Longitude, Altitude
3) Euler: Roll, Pitch, Azimuth
4) Euler Rates: Roll Rate, Pitch Rate, Azimuth Rate
5) Velocity: Velocity North, Velocity East, Velocity Down
6) Velocity Total: **calculated from selected N/E/D**
7) Status: StatusValue (bitmask)
8) Course

## UI placement decision (CONFIRMED DIRECTION)
- Start/Stop recording controls should live in the **MainWindow title bar row** (`AppTitleBar`) so it’s always visible
- We did not implement it yet

## Next continuation (tomorrow)
We will continue with a cleaner “other way” approach (not started yet), but the immediate technical tasks waiting are:

1) Fix TEMP `IntegratedInsOutputItem.Process()` OutputTime column ordering
2) Define NIS recorder architecture:
   - Raw device recording (per device type payloads)
   - Integrated output recording (DataRecordType=50)
   - Stable device instance indexing per session (DeviceCode + DeviceId)
3) Decide the exact sampling strategy (timer vs event-driven) for recording
4) Add shell-level recording controls in MainWindow title bar + ViewModel commands
5) Wire Integration selection snapshot -> `IntegratedInsOutput_Data` builder (including VelocityTotal derived rule)

Stop point: **No implementation started yet**


// ---------------------------------------------------------
// FILE: .\Preferences.md
// ---------------------------------------------------------

**Role:** You are a Senior C# & WinUI 3 Software Engineer assisting with the development of "NavigationIntegrationSystem" (NIS).

**Context:**
- You have full access to the project structure and source code in your Knowledge base.
- The project is a modular navigation system integrating various INS devices (VN310, Tmaps100X, etc.) via UDP/TCP/Serial.
- It uses MVVM (CommunityToolkit), Dependency Injection (Microsoft.Extensions), and WinUI 3.

**Strict Protocols:**
1.  **The "Ask First" Rule:** If a request requires editing a file that is NOT in the Knowledge base or the current chat context, DO NOT hallucinate the content. Ask: "Please provide the current code for [Filename]."
2.  **Zero-Inference:** Do not assume methods or libraries exist unless seen in the provided code.
3.  **Visual Studio Context:** Assume the user is working in Visual Studio 2026.

**Coding Standards (Immutable):**
* **Naming Conventions:**
    * **Classes/Properties:** `PascalCase`
    * **Private Fields:** `m_PascalCase` (e.g., `m_IsConnected`)
    * **Method Parameters:** `i_PascalCase` (e.g., `i_Device`)
    * **Local Variables:** `camelCase`
    * **Commands:** `[Action]Command` (e.g., `ApplySettingsCommand`)
    
* **Class Structure (Strict Region Order):**
    1.  `#region Properties`
    2.  `#region Private Fields`
    3.  `#region Commands`
    4.  `#region Constructors`
    5.  `#region Functions`
    6.  `#region Event Handlers`

* **MVVM (Manual Implementation):**
    * Use `ViewModelBase` with `SetProperty`.
    * **Strictly Forbidden:** CommunityToolkit source generators (`[ObservableProperty]`, `[RelayCommand]`).
    * Commands must be explicit properties (e.g., `public IRelayCommand SaveCommand { get; }`).

* * **XAML Guidelines:**
    * **Hot Reload Rule:** Always declare `Grid.RowDefinitions` and `Grid.ColumnDefinitions` explicitly. Never inline them.
    * **Formatting:** Prefer single-line elements
- **Density:** One-liners for simple properties/guards. No `var` (unless lambda). No `temp` variable names.
- **UI:** Keep ViewModels decoupled from View logic.

**Interaction Style:**
- No conversational filler
- Provide direct, copy-pasteable code blocks.
- Focus on architectural consistency and handling edge cases (e.g., thread safety, valid/invalid states).
- If you think there's a better architectural approach, propose it with justification.
- Always prioritize maintainability and scalability in your solutions. No quick fixes.
- If a file is missing from context, ask for it or propose its creation if it's a new requirement.

// ---------------------------------------------------------
// FILE: .\bin\x64\Debug\net8.0-windows10.0.19041.0\win-x64\appsettings.json
// ---------------------------------------------------------

{
  "Nis": {
    "Log": {
      "Root": "{BaseDirectory}\\Logs",
      "MaxUiEntries": 2000
    }
  }
}


// ---------------------------------------------------------
// FILE: .\IntegratedInsOutputItem.cs
// ---------------------------------------------------------

using Infrastructure.FileManagement.DataRecording;
using Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;
using System;
using System.Collections.Generic;

namespace RecordDecoderPro.ItemTemplates
{
    internal sealed class IntegratedInsOutputItem : RecordTypeItem
    {
        #region Properties

        public IntegratedInsOutputDictionary OutputDict { get; private set; }

        #endregion

        #region Columns

        public static readonly string[] IntegratedInsOutputColumns =
        {
            "RcvTime[hms]", "RcvTime[sec]",

            "OutputTimeDeviceCode", "OutputTimeDeviceId", "OutputTime[hms]", "OutputTime[sec]",

            "PositionLatDeviceCode", "PositionLatDeviceId", "PositionLatValue",
            "PositionLonDeviceCode", "PositionLonDeviceId", "PositionLonValue",
            "PositionAltDeviceCode", "PositionAltDeviceId", "PositionAltValue",

            "EulerRollDeviceCode", "EulerRollDeviceId", "EulerRollValue",
            "EulerPitchDeviceCode", "EulerPitchDeviceId", "EulerPitchValue",
            "EulerAzimuthDeviceCode", "EulerAzimuthDeviceId", "EulerAzimuthValue",

            "EulerRollRateDeviceCode", "EulerRollRateDeviceId", "EulerRollRateValue",
            "EulerPitchRateDeviceCode", "EulerPitchRateDeviceId", "EulerPitchRateValue",
            "EulerAzimuthRateDeviceCode", "EulerAzimuthRateDeviceId", "EulerAzimuthRateValue",

            "VelocityTotalDeviceCode", "VelocityTotalDeviceId", "VelocityTotalValue",
            "VelocityNorthDeviceCode", "VelocityNorthDeviceId", "VelocityNorthValue",
            "VelocityEastDeviceCode", "VelocityEastDeviceId", "VelocityEastValue",
            "VelocityDownDeviceCode", "VelocityDownDeviceId", "VelocityDownValue",

            "StatusDeviceCode", "StatusDeviceId", "StatusValue",
            "CourseDeviceCode", "CourseDeviceId", "CourseValue",
        };

        #endregion

        #region Triplet Helpers

        public IntegratedValueTriplet PositionLat => new(LatitudeDeviceCode, LatitudeDeviceId, Position.Lat);
        public IntegratedValueTriplet PositionLon => new(LongitudeDeviceCode, LongitudeDeviceId, Position.Lon);
        public IntegratedValueTriplet PositionAlt => new(AltitudeDeviceCode, AltitudeDeviceId, Position.Alt);

        public IntegratedValueTriplet EulerRoll => new(RollDeviceCode, RollDeviceId, EulerData.Angles.Roll);
        public IntegratedValueTriplet EulerPitch => new(PitchDeviceCode, PitchDeviceId, EulerData.Angles.Pitch);
        public IntegratedValueTriplet EulerAzimuth => new(AzimuthDeviceCode, AzimuthDeviceId, EulerData.Angles.Yaw);

        public IntegratedValueTriplet EulerRollRate => new(RollRateDeviceCode, RollRateDeviceId, EulerData.Rates.Roll);
        public IntegratedValueTriplet EulerPitchRate => new(PitchRateDeviceCode, PitchRateDeviceId, EulerData.Rates.Pitch);
        public IntegratedValueTriplet EulerAzimuthRate => new(AzimuthRateDeviceCode, AzimuthRateDeviceId, EulerData.Rates.Yaw);

        public IntegratedValueTriplet VelocityTotal => new(VelocityTotalDeviceCode, VelocityTotalDeviceId, VelocityTotal);
        public IntegratedValueTriplet VelocityNorth => new(VelocityNorthDeviceCode, VelocityNorthDeviceId, VelocityVector.North);
        public IntegratedValueTriplet VelocityEast => new(VelocityEastDeviceCode, VelocityEastDeviceId, VelocityVector.East);
        public IntegratedValueTriplet VelocityDown => new(VelocityDownDeviceCode, VelocityDownDeviceId, VelocityVector.Down);

        public IntegratedValueTriplet Status => new(StatusDeviceCode, StatusDeviceId, StatusValue);
        public IntegratedValueTriplet Course => new(CourseDeviceCode, CourseDeviceId, Course);

        #endregion

        #region Constructors

        public IntegratedInsOutputItem() : base()
        {
            ColumnsNames = IntegratedInsOutputColumns;
        }

        #endregion

        #region Functions

        // Initializes item dictionary from raw binary payload
        public void InitializeDict(DataRecordHeader i_Header, byte[] i_RawData)
        {
            OutputDict = new IntegratedInsOutputDictionary(i_Header, i_RawData);
            dict = OutputDict.Dictionary;
        }

        #endregion

        #region Nested Types

        internal sealed class IntegratedInsOutputDictionary
        {
            #region Properties

            public Dictionary<string, string> Dictionary { get; }

            #endregion

            #region Constructors

            public IntegratedInsOutputDictionary(DataRecordHeader i_Header, byte[] i_RawData)
            {
                Dictionary = new Dictionary<string, string>();
                Process(i_Header, i_RawData);
            }

            #endregion

            #region Private Functions

            // Decodes integrated output using a CommFrame and formats values into CSV-ready columns
            private void Process(DataRecordHeader i_Header, byte[] i_RawData)
            {
                int i = 0;

                IntegratedInsOutputCommFrame frame = new IntegratedInsOutputCommFrame();
                frame.DecodeBinaryData(i_RawData, i_Header.DataLength);

                DateTime rcvTime = DateTime.FromBinary(i_Header.Time);
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{rcvTime:HH:mm:ss.fff},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{rcvTime.TimeOfDay.TotalSeconds:F4},");

                DateTime outputTime = frame.Data.OutputTimeUtc;
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTimeDeviceCode},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTimeDeviceId},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{outputTime:HH:mm:ss.fff},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{outputTime.TimeOfDay.TotalSeconds:F4},");

                AddTriplet(ref i, frame.Data.PositionLat);
                AddTriplet(ref i, frame.Data.PositionLon);
                AddTriplet(ref i, frame.Data.PositionAlt);

                AddTriplet(ref i, frame.Data.EulerRoll);
                AddTriplet(ref i, frame.Data.EulerPitch);
                AddTriplet(ref i, frame.Data.EulerAzimuth);

                AddTriplet(ref i, frame.Data.EulerRollRate);
                AddTriplet(ref i, frame.Data.EulerPitchRate);
                AddTriplet(ref i, frame.Data.EulerAzimuthRate);

                AddTriplet(ref i, frame.Data.VelocityTotal);
                AddTriplet(ref i, frame.Data.VelocityNorth);
                AddTriplet(ref i, frame.Data.VelocityEast);
                AddTriplet(ref i, frame.Data.VelocityDown);

                AddTriplet(ref i, frame.Data.Status);
                AddTriplet(ref i, frame.Data.Course);
            }

            // Adds DeviceCode + DeviceId + Value using the current column index
            private void AddTriplet(ref int io_Index, IntegratedValueTriplet i_Triplet)
            {
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.DeviceCode},");
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.DeviceId},");
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.Value:F8},");
            }

            #endregion
        }

        #endregion
    }
}


// ---------------------------------------------------------
// FILE: .\IntegratedInsOutputStatusFlags.cs
// ---------------------------------------------------------

using System;
using System.IO;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

// Unified status flags for IntegratedInsOutput_Data StatusValue (bitmask)
[Flags]
public enum IntegratedInsOutputStatusFlags : uint
{
    None = 0,

    // Time
    OutputTimeValid = 1u << 0,

    // Position
    PositionLatValid = 1u << 1,
    PositionLonValid = 1u << 2,
    PositionAltValid = 1u << 3,

    // Euler Angles
    RollValid = 1u << 4,
    PitchValid = 1u << 5,
    AzimuthValid = 1u << 6,

    // Euler Rates
    RollRateValid = 1u << 7,
    PitchRateValid = 1u << 8,
    AzimuthRateValid = 1u << 9,

    // Velocity
    VelocityTotalValid = 1u << 10,
    VelocityNorthValid = 1u << 11,
    VelocityEastValid = 1u << 12,
    VelocityDownValid = 1u << 13,

    // Course
    CourseValid = 1u << 14,

    // Generic / future
    Reserved15 = 1u << 15
}

// ---------------------------------------------------------
// FILE: .\IntegratedInsOutput_CommFrame.cs
// ---------------------------------------------------------

using Infrastructure.Enums;
using System.IO;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

// Builds/decodes the integrated INS output binary frame (sync + payload + checksum)
public sealed class IntegratedInsOutput_CommFrame
{
    #region Constants

    // Frame sync byte (define a real constant and keep it stable once chosen)
    private const byte m_Sync = 0x50;

    #endregion

    #region Private Fields

    private readonly object m_LockObject;
    private IntegratedInsOutputData m_Data;
    private byte m_Checksum;

    #endregion

    #region Properties

    public static int BinLength { get; } = IntegratedInsOutputData.BinLength + 2 * sizeof(byte);

    public IntegratedInsOutputData Data
    {
        get { lock (m_LockObject) { return m_Data.Clone(); } }
    }

    #endregion

    #region Constructors

    // Creates a new integrated output comm frame
    public IntegratedInsOutput_CommFrame()
    {
        m_LockObject = new object();
        m_Data = new IntegratedInsOutputData();
        m_Checksum = 0;
    }

    #endregion

    #region Decode

    // Decodes a full frame from a byte array
    public BinaryDataDecodingStatus DecodeBinaryData(byte[] i_BinaryData, int i_DataSize)
    {
        if (i_BinaryData == null || i_DataSize <= 0) { return BinaryDataDecodingStatus.LengthError; }
        if (i_DataSize < BinLength) { return BinaryDataDecodingStatus.LengthError; }

        using (MemoryStream m = new MemoryStream(i_BinaryData))
        using (BinaryReader reader = new BinaryReader(m))
        {
            return DecodeBinaryData(reader, i_BinaryData, i_DataSize);
        }
    }

    // Decodes a full frame from a reader (and optionally validates checksum using the source buffer)
    public BinaryDataDecodingStatus DecodeBinaryData(BinaryReader i_Reader, byte[] i_SourceBuffer, int i_DataSize)
    {
        if (i_Reader == null) { return BinaryDataDecodingStatus.LengthError; }
        if (i_DataSize < BinLength) { return BinaryDataDecodingStatus.LengthError; }

        byte sync = i_Reader.ReadByte();

        IntegratedInsOutputData tmpData = new IntegratedInsOutputData();
        tmpData.ReadBinary(i_Reader);

        byte checksum = i_Reader.ReadByte();

        if (sync != m_Sync) { return BinaryDataDecodingStatus.SyncError; }

        // Validates checksum (keep enabled/disabled consistently across the whole recording ecosystem)
        if (i_SourceBuffer != null)
        {
            byte expected = CalculateChecksum(i_SourceBuffer, BinLength);
            // If you want strict validation, uncomment this check (and match it in the encoder)
            // if (checksum != expected) { return BinaryDataDecodingStatus.ChecksumError; }
        }

        lock (m_LockObject)
        {
            m_Data = tmpData;
            m_Checksum = checksum;
        }

        return BinaryDataDecodingStatus.Success;
    }

    #endregion

    #region Encode

    // Encodes a full frame into a provided output array
    public void EncodeBinaryData(ref byte[] io_OutArray, ref int io_Size)
    {
        if (io_OutArray == null || io_OutArray.Length < BinLength) { io_Size = 0; return; }

        using (MemoryStream m = new MemoryStream(io_OutArray))
        using (BinaryWriter writer = new BinaryWriter(m))
        {
            writer.Write(m_Sync);

            IntegratedInsOutputData snapshot = Data;
            snapshot.Encode(writer);

            writer.Write((byte)0); // placeholder checksum, overwritten below
        }

        byte checksum = CalculateChecksum(io_OutArray, BinLength);
        io_OutArray[BinLength - 1] = checksum;
        io_Size = BinLength;

        lock (m_LockObject)
        {
            m_Checksum = checksum;
        }
    }

    #endregion

    #region Private Helpers

    // Calculates a simple additive checksum over the frame, excluding the checksum byte itself
    private static byte CalculateChecksum(byte[] i_Buffer, int i_FrameLength)
    {
        byte checksum = 0;

        // Sum bytes [1..FrameLength-2] like StdInsCommFrame (exclude sync at 0 and checksum at last)
        for (int i = 1; i < i_FrameLength - 1; i++)
        {
            checksum += i_Buffer[i];
        }

        return checksum;
    }

    #endregion
}


// ---------------------------------------------------------
// FILE: .\IntegratedInsOutput_Data.cs
// ---------------------------------------------------------

using System;
using System.IO;

using Infrastructure.DataStructures;
using Infrastructure.Navigation.EulerCalculations;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

public sealed class IntegratedInsOutput_Data
{
    #region Private Fields
    private DateTime m_OutputTime;
    private WGS84Data m_Position;
    private EulerData m_EulerData;
    private NEDData m_NedVelocity;
    private double m_Course;
    private uint m_StatusValue;
    private readonly object m_LockObject;
    #endregion

    #region Properties

    // Output time (selected source)
    public ushort OutputTimeDeviceCode { get; set; }
    public ushort OutputTimeDeviceId { get; set; }
    public DateTime OutputTime { get { lock (m_LockObject) { return m_OutputTime; } } set { lock (m_LockObject) { m_OutputTime = value; } } }

    // Position sources (per field)
    public ushort LatitudeDeviceCode { get; set; }
    public ushort LatitudeDeviceId { get; set; }
    public ushort LongitudeDeviceCode { get; set; }
    public ushort LongitudeDeviceId { get; set; }
    public ushort AltitudeDeviceCode { get; set; }
    public ushort AltitudeDeviceId { get; set; }

    // Euler angles sources (per field)
    public ushort RollDeviceCode { get; set; }
    public ushort RollDeviceId { get; set; }
    public ushort PitchDeviceCode { get; set; }
    public ushort PitchDeviceId { get; set; }
    public ushort AzimuthDeviceCode { get; set; }
    public ushort AzimuthDeviceId { get; set; }

    // Euler rates sources (per field)
    public ushort RollRateDeviceCode { get; set; }
    public ushort RollRateDeviceId { get; set; }
    public ushort PitchRateDeviceCode { get; set; }
    public ushort PitchRateDeviceId { get; set; }
    public ushort AzimuthRateDeviceCode { get; set; }
    public ushort AzimuthRateDeviceId { get; set; }

    // Velocity sources (per field)
    public ushort VelocityTotalDeviceCode { get; set; }
    public ushort VelocityTotalDeviceId { get; set; }
    public ushort VelocityNorthDeviceCode { get; set; }
    public ushort VelocityNorthDeviceId { get; set; }
    public ushort VelocityEastDeviceCode { get; set; }
    public ushort VelocityEastDeviceId { get; set; }
    public ushort VelocityDownDeviceCode { get; set; }
    public ushort VelocityDownDeviceId { get; set; }

    // Status sources (single value)
    public ushort StatusDeviceCode { get; set; }
    public ushort StatusDeviceId { get; set; }
    public uint StatusValue { get { lock (m_LockObject) { return m_StatusValue; } } set { lock (m_LockObject) { m_StatusValue = value; } } }

    // Course sources (single value)
    public ushort CourseDeviceCode { get; set; }
    public ushort CourseDeviceId { get; set; }

    // Position (values)
    public WGS84Data Position { get { lock (m_LockObject) { return m_Position.Clone(); } } set { lock (m_LockObject) { m_Position = value.Clone(); } } }
    public WGS84Data Position_Deg { get { lock (m_LockObject) { var p = m_Position.Clone(); p.ConvertToDegrees(); return p; } } }

    // Euler (values)
    public EulerData EulerData { get { lock (m_LockObject) { return m_EulerData.Clone(); } } set { lock (m_LockObject) { m_EulerData = value.Clone(); } } }
    public EulerData EulerData_Deg { get { lock (m_LockObject) { var e = m_EulerData.Clone(); e.ConvertToDegrees(); return e; } } }

    // Velocity (values)
    public NEDData VelocityVector { get { lock (m_LockObject) { return m_NedVelocity.Clone(); } } set { lock (m_LockObject) { m_NedVelocity = value.Clone(); } } }
    public double VelocityTotal { get { lock (m_LockObject) { return Math.Sqrt(m_NedVelocity.Down * m_NedVelocity.Down + m_NedVelocity.East * m_NedVelocity.East + m_NedVelocity.North * m_NedVelocity.North); } } }

    // Course (value)
    public double Course { get { lock (m_LockObject) { return m_Course; } } set { lock (m_LockObject) { m_Course = value; } } }

    // Binary payload length for CommFrame Encode/Decode
    public static int BinLength
    {
        get
        {
            // OutputTime: DeviceCode(ushort) + DeviceId(ushort) + DateTimeBinary(long)
            // 14 numeric fields: each DeviceCode(ushort) + DeviceId(ushort) + Value(double)
            // Status: DeviceCode(ushort) + DeviceId(ushort) + Value(uint)
            return (2 * sizeof(ushort) + sizeof(long)) + (14 * (2 * sizeof(ushort) + sizeof(double))) + (2 * sizeof(ushort) + sizeof(uint));
        }
    }

    #endregion

    #region Constructors

    // Creates a new integrated output data instance
    public IntegratedInsOutput_Data()
    {
        m_LockObject = new object();
        m_Position = new WGS84Data();
        m_EulerData = new EulerData();
        m_NedVelocity = new NEDData();
        Clear();
    }

    #endregion

    #region Functions

    // Resets values and sources to defaults
    public void Clear()
    {
        lock (m_LockObject)
        {
            OutputTimeDeviceCode = 0; OutputTimeDeviceId = 0; m_OutputTime = DateTime.UtcNow;

            LatitudeDeviceCode = 0; LatitudeDeviceId = 0;
            LongitudeDeviceCode = 0; LongitudeDeviceId = 0;
            AltitudeDeviceCode = 0; AltitudeDeviceId = 0;

            RollDeviceCode = 0; RollDeviceId = 0;
            PitchDeviceCode = 0; PitchDeviceId = 0;
            AzimuthDeviceCode = 0; AzimuthDeviceId = 0;

            RollRateDeviceCode = 0; RollRateDeviceId = 0;
            PitchRateDeviceCode = 0; PitchRateDeviceId = 0;
            AzimuthRateDeviceCode = 0; AzimuthRateDeviceId = 0;

            VelocityTotalDeviceCode = 0; VelocityTotalDeviceId = 0;
            VelocityNorthDeviceCode = 0; VelocityNorthDeviceId = 0;
            VelocityEastDeviceCode = 0; VelocityEastDeviceId = 0;
            VelocityDownDeviceCode = 0; VelocityDownDeviceId = 0;

            StatusDeviceCode = 0; StatusDeviceId = 0; m_StatusValue = 0;

            CourseDeviceCode = 0; CourseDeviceId = 0; m_Course = 0;

            m_Position.Clear();
            m_EulerData.Clear();
            m_NedVelocity.Clear();
        }
    }

    // Creates a deep copy of the instance
    public IntegratedInsOutput_Data Clone()
    {
        var outValue = new IntegratedInsOutput_Data();
        lock (m_LockObject)
        {
            outValue.OutputTimeDeviceCode = OutputTimeDeviceCode;
            outValue.OutputTimeDeviceId = OutputTimeDeviceId;
            outValue.m_OutputTime = m_OutputTime;

            outValue.LatitudeDeviceCode = LatitudeDeviceCode; outValue.LatitudeDeviceId = LatitudeDeviceId;
            outValue.LongitudeDeviceCode = LongitudeDeviceCode; outValue.LongitudeDeviceId = LongitudeDeviceId;
            outValue.AltitudeDeviceCode = AltitudeDeviceCode; outValue.AltitudeDeviceId = AltitudeDeviceId;

            outValue.RollDeviceCode = RollDeviceCode; outValue.RollDeviceId = RollDeviceId;
            outValue.PitchDeviceCode = PitchDeviceCode; outValue.PitchDeviceId = PitchDeviceId;
            outValue.AzimuthDeviceCode = AzimuthDeviceCode; outValue.AzimuthDeviceId = AzimuthDeviceId;

            outValue.RollRateDeviceCode = RollRateDeviceCode; outValue.RollRateDeviceId = RollRateDeviceId;
            outValue.PitchRateDeviceCode = PitchRateDeviceCode; outValue.PitchRateDeviceId = PitchRateDeviceId;
            outValue.AzimuthRateDeviceCode = AzimuthRateDeviceCode; outValue.AzimuthRateDeviceId = AzimuthRateDeviceId;

            outValue.VelocityTotalDeviceCode = VelocityTotalDeviceCode; outValue.VelocityTotalDeviceId = VelocityTotalDeviceId;
            outValue.VelocityNorthDeviceCode = VelocityNorthDeviceCode; outValue.VelocityNorthDeviceId = VelocityNorthDeviceId;
            outValue.VelocityEastDeviceCode = VelocityEastDeviceCode; outValue.VelocityEastDeviceId = VelocityEastDeviceId;
            outValue.VelocityDownDeviceCode = VelocityDownDeviceCode; outValue.VelocityDownDeviceId = VelocityDownDeviceId;

            outValue.StatusDeviceCode = StatusDeviceCode; outValue.StatusDeviceId = StatusDeviceId; outValue.m_StatusValue = m_StatusValue;

            outValue.CourseDeviceCode = CourseDeviceCode; outValue.CourseDeviceId = CourseDeviceId; outValue.m_Course = m_Course;

            outValue.m_Position = m_Position.Clone();
            outValue.m_EulerData = m_EulerData.Clone();
            outValue.m_NedVelocity = m_NedVelocity.Clone();
        }
        return outValue;
    }

    // Reads the binary payload in the locked field order
    public void ReadBinary(BinaryReader i_Reader)
    {
        lock (m_LockObject)
        {
            OutputTimeDeviceCode = i_Reader.ReadUInt16();
            OutputTimeDeviceId = i_Reader.ReadUInt16();
            m_OutputTime = DateTime.FromBinary(i_Reader.ReadInt64());

            LatitudeDeviceCode = i_Reader.ReadUInt16();
            LatitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Lat = i_Reader.ReadDouble();

            LongitudeDeviceCode = i_Reader.ReadUInt16();
            LongitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Lon = i_Reader.ReadDouble();

            AltitudeDeviceCode = i_Reader.ReadUInt16();
            AltitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Alt = i_Reader.ReadDouble();

            RollDeviceCode = i_Reader.ReadUInt16();
            RollDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Roll = i_Reader.ReadDouble();

            PitchDeviceCode = i_Reader.ReadUInt16();
            PitchDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Pitch = i_Reader.ReadDouble();

            AzimuthDeviceCode = i_Reader.ReadUInt16();
            AzimuthDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Yaw = i_Reader.ReadDouble();

            RollRateDeviceCode = i_Reader.ReadUInt16();
            RollRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Roll = i_Reader.ReadDouble();

            PitchRateDeviceCode = i_Reader.ReadUInt16();
            PitchRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Pitch = i_Reader.ReadDouble();

            AzimuthRateDeviceCode = i_Reader.ReadUInt16();
            AzimuthRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Yaw = i_Reader.ReadDouble();

            VelocityTotalDeviceCode = i_Reader.ReadUInt16();
            VelocityTotalDeviceId = i_Reader.ReadUInt16();
            var velocityTotal = i_Reader.ReadDouble(); // Stored as a field even if derivable

            VelocityNorthDeviceCode = i_Reader.ReadUInt16();
            VelocityNorthDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.North = i_Reader.ReadDouble();

            VelocityEastDeviceCode = i_Reader.ReadUInt16();
            VelocityEastDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.East = i_Reader.ReadDouble();

            VelocityDownDeviceCode = i_Reader.ReadUInt16();
            VelocityDownDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.Down = i_Reader.ReadDouble();

            StatusDeviceCode = i_Reader.ReadUInt16();
            StatusDeviceId = i_Reader.ReadUInt16();
            m_StatusValue = i_Reader.ReadUInt32();

            CourseDeviceCode = i_Reader.ReadUInt16();
            CourseDeviceId = i_Reader.ReadUInt16();
            m_Course = i_Reader.ReadDouble();

            // Keep the stored total as-is if you later want to expose it directly
            _ = velocityTotal;
        }
    }

    // Encodes the binary payload in the locked field order
    public void Encode(BinaryWriter i_Writer)
    {
        lock (m_LockObject)
        {
            i_Writer.Write(OutputTimeDeviceCode);
            i_Writer.Write(OutputTimeDeviceId);
            i_Writer.Write(m_OutputTime.ToBinary());

            i_Writer.Write(LatitudeDeviceCode);
            i_Writer.Write(LatitudeDeviceId);
            i_Writer.Write(m_Position.Lat);

            i_Writer.Write(LongitudeDeviceCode);
            i_Writer.Write(LongitudeDeviceId);
            i_Writer.Write(m_Position.Lon);

            i_Writer.Write(AltitudeDeviceCode);
            i_Writer.Write(AltitudeDeviceId);
            i_Writer.Write(m_Position.Alt);

            i_Writer.Write(RollDeviceCode);
            i_Writer.Write(RollDeviceId);
            i_Writer.Write(m_EulerData.Angles.Roll);

            i_Writer.Write(PitchDeviceCode);
            i_Writer.Write(PitchDeviceId);
            i_Writer.Write(m_EulerData.Angles.Pitch);

            i_Writer.Write(AzimuthDeviceCode);
            i_Writer.Write(AzimuthDeviceId);
            i_Writer.Write(m_EulerData.Angles.Yaw);

            i_Writer.Write(RollRateDeviceCode);
            i_Writer.Write(RollRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Roll);

            i_Writer.Write(PitchRateDeviceCode);
            i_Writer.Write(PitchRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Pitch);

            i_Writer.Write(AzimuthRateDeviceCode);
            i_Writer.Write(AzimuthRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Yaw);

            i_Writer.Write(VelocityTotalDeviceCode);
            i_Writer.Write(VelocityTotalDeviceId);
            i_Writer.Write(VelocityTotal); // Stored total

            i_Writer.Write(VelocityNorthDeviceCode);
            i_Writer.Write(VelocityNorthDeviceId);
            i_Writer.Write(m_NedVelocity.North);

            i_Writer.Write(VelocityEastDeviceCode);
            i_Writer.Write(VelocityEastDeviceId);
            i_Writer.Write(m_NedVelocity.East);

            i_Writer.Write(VelocityDownDeviceCode);
            i_Writer.Write(VelocityDownDeviceId);
            i_Writer.Write(m_NedVelocity.Down);

            i_Writer.Write(StatusDeviceCode);
            i_Writer.Write(StatusDeviceId);
            i_Writer.Write(m_StatusValue);

            i_Writer.Write(CourseDeviceCode);
            i_Writer.Write(CourseDeviceId);
            i_Writer.Write(m_Course);
        }
    }

    #endregion
}


// ---------------------------------------------------------
// FILE: .\IntegratedValueTriplet.cs
// ---------------------------------------------------------

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput
{
    public struct IntegratedValueTriplet
    {
        public ushort DeviceCode { get; }
        public ushort DeviceId { get; }
        public double Value { get; }

        public IntegratedValueTriplet(ushort i_DeviceCode, ushort i_DeviceId, double i_Value)
        {
            DeviceCode = i_DeviceCode;
            DeviceId = i_DeviceId;
            Value = i_Value;
        }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\NavigationIntegrationSystem.Core.csproj
// ---------------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
	  <TargetFramework>net8.0</TargetFramework>
	  <RootNamespace>NavigationIntegrationSystem.Core</RootNamespace>
	<Nullable>enable</Nullable>
	<Platforms>AnyCPU;x64</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <Folder Include="Models\Recording\" />
  </ItemGroup>
</Project>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Devices\IInsDevice.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Models.Devices;
using System;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.Core.Devices;

// Defines a runtime INS device instance
public interface IInsDevice
{
    #region Properties
    DeviceDefinition Definition { get; }
    DeviceStatus Status { get; }
    string? LastError { get; }
    #endregion

    #region Events
    event EventHandler? StateChanged;
    #endregion

    #region Functions
    // Connects to the device
    Task ConnectAsync();

    // Disconnects from the device
    Task DisconnectAsync();
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Devices\IInsDeviceInstanceProvider.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;

namespace NavigationIntegrationSystem.Core.Devices;

// Provides stable, session-wide unique indices for device instances of the same type
public interface IInsDeviceInstanceProvider
{
    // Returns the session-stable ID for a specific device instance
    ushort GetInstanceId(IInsDevice i_Device);
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Enums\DeviceStatus.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Core.Enums;

// Represents the current runtime status of a device connection
public enum DeviceStatus
{
    Disconnected,
    Connecting,
    Connected,
    Error
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Enums\DeviceType.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Core.Enums;

// Defines supported INS device types in the application
public enum DeviceType
{
    Manual,
    VN310,
    Tmaps100X
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Logging\ILogPaths.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Core.Logging;

// Exposes log-related paths to UI without referencing infrastructure types
public interface ILogPaths
{
    string LogFolderPath { get; }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Logging\ILogService.cs
// ---------------------------------------------------------

using System;

namespace NavigationIntegrationSystem.Core.Logging;

// Minimal logging contract used by non-UI layers
public interface ILogService
{
    event Action<LogRecord>? RecordWritten;

    void Info(string i_Source, string i_Message);
    void Debug(string i_Source, string i_Message);
    void Warn(string i_Source, string i_Message);
    void Error(string i_Source, string i_Message, Exception? i_Exception = null);
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Logging\LogLevel.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Core.Logging;

// Defines supported log severities
public enum LogLevel
{
    Debug,
    Info,
    Warn,
    Error
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Logging\LogRecord.cs
// ---------------------------------------------------------

using System;

namespace NavigationIntegrationSystem.Core.Logging;

// Immutable log record produced by the system
public sealed class LogRecord
{
    #region Properties
    public DateTime TimestampUtc { get; }
    public LogLevel Level { get; }
    public string Source { get; }
    public string Message { get; }
    public string? ExceptionText { get; }
    #endregion

    #region Ctors
    public LogRecord(DateTime i_TimestampUtc, LogLevel i_Level, string i_Source, string i_Message, string? i_ExceptionText)
    {
        TimestampUtc = i_TimestampUtc;
        Level = i_Level;
        Source = i_Source;
        Message = i_Message;
        ExceptionText = i_ExceptionText;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Models\Devices\DeviceDefinition.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Models.DeviceCatalog;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Core.Models.Devices;

// Defines a fixed device instance in the app, including its inspectable fields
public sealed class DeviceDefinition
{
    #region Properties
    public DeviceType Type { get; }
    public string DisplayName => Type.ToString();
    public IReadOnlyList<DeviceFieldDefinition> Fields { get; }
    #endregion

    #region Ctors
    public DeviceDefinition(DeviceType i_Type, IReadOnlyList<DeviceFieldDefinition> i_Fields)
    {
        Type = i_Type;
        Fields = i_Fields;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Models\Devices\DeviceFieldDefinition.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Core.Models.DeviceCatalog;

// Defines a single field that can be displayed in Inspect for a device
public sealed class DeviceFieldDefinition
{
    #region Properties
    public string Key { get; }
    public string DisplayName { get; }
    public string Unit { get; }
    #endregion

    #region Ctors
    public DeviceFieldDefinition(string i_Key, string i_DisplayName, string i_Unit)
    {
        Key = i_Key;
        DisplayName = i_DisplayName;
        Unit = i_Unit;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Core\Recording\IRecordingService.cs
// ---------------------------------------------------------

using System;

namespace NavigationIntegrationSystem.Core.Recording;

public interface IRecordingService
{
    #region Properties
    bool IsRecording { get; }
    #endregion

    #region Events
    event EventHandler<bool>? RecordingStateChanged;
    #endregion

    #region Functions
    // Starts the recording session
    void Start();

    // Stops the recording session
    void Stop();

    // Records the Integrated INS Output record (Type 50)
    void RecordIntegratedOutput(object i_DataSnapshot);
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\NavigationIntegrationSystem.Devices.csproj
// ---------------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
	  <TargetFramework>net8.0</TargetFramework>
	  <RootNamespace>NavigationIntegrationSystem.Devices</RootNamespace>
	  <Nullable>enable</Nullable>
	  <Platforms>AnyCPU;x64</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\NavigationIntegrationSystem.Core\NavigationIntegrationSystem.Core.csproj" />
  </ItemGroup>
</Project>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Catalog\DeviceCatalogService.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Modules;
using System.Collections.Generic;
using System.Linq;

namespace NavigationIntegrationSystem.Devices.Catalog;

// Provides the fixed list of device instances and their inspectable field definitions
public sealed class DeviceCatalogService
{
    #region Private Fields
    private readonly IEnumerable<IInsDeviceModule> m_Modules;
    #endregion

    #region Ctors
    public DeviceCatalogService(IEnumerable<IInsDeviceModule> i_Modules)
    {
        m_Modules = i_Modules;
    }
    #endregion

    #region Functions
    // Returns the fixed device definitions used by the application (the order is by device type for consistency)
    public IReadOnlyList<DeviceDefinition> GetDevices()
    {
        return m_Modules.OrderBy(m => m.Type).Select(m => m.BuildDefinition()).ToList();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Connections\SerialConnectionSettings.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Devices.Enums;

namespace NavigationIntegrationSystem.Devices.Connections;

// Serial connection parameters
public sealed class SerialConnectionSettings
{
    #region Properties
    public SerialLineKind SerialLineKind { get; set; } = SerialLineKind.Rs232;
    public string ComPort { get; set; } = "COM1";
    public int BaudRate { get; set; } = 115200;
    #endregion

    #region Functions
    // Copies values from another instance
    public void CopyFrom(SerialConnectionSettings i_Source)
    {
        if (i_Source == null) { return; }
        SerialLineKind = i_Source.SerialLineKind;
        ComPort = i_Source.ComPort;
        BaudRate = i_Source.BaudRate;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Connections\TcpConnectionSettings.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Devices.Connections;

// TCP connection parameters
public sealed class TcpConnectionSettings
{
    #region Properties
    public string Host { get; set; } = "127.0.0.1";
    public int Port { get; set; } = 5000;
    #endregion

    #region Functions
    // Copies values from another instance
    public void CopyFrom(TcpConnectionSettings i_Source)
    {
        if (i_Source == null) { return; }
        Host = i_Source.Host;
        Port = i_Source.Port;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Connections\UdpConnectionSettings.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Devices.Connections;

// UDP connection parameters
public sealed class UdpConnectionSettings
{
    #region Properties
    public string RemoteIp { get; set; } = "127.0.0.1";
    public int RemotePort { get; set; } = 5000;
    public string LocalIp { get; set; } = "0.0.0.0";
    public int LocalPort { get; set; } = 5000;
    #endregion

    #region Functions
    // Copies values from another instance
    public void CopyFrom(UdpConnectionSettings i_Source)
    {
        if (i_Source == null) { return; }
        RemoteIp = i_Source.RemoteIp;
        RemotePort = i_Source.RemotePort;
        LocalIp = i_Source.LocalIp;
        LocalPort = i_Source.LocalPort;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Enums\DeviceConnectionKind.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Devices.Enums;

// Defines the connection kind used by a device
public enum DeviceConnectionKind
{
    Udp,
    Tcp,
    Serial
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Enums\SerialLineKind.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Devices.Enums;

// Defines serial electrical line type for device connections
public enum SerialLineKind
{
    Rs232,
    Rs422,
    Rs485
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Implementations\ManualInsDevice.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.Devices.Implementations;

// Runtime device implementation for Manual (always available, no IO)
public sealed class ManualInsDevice : InsDeviceBase
{
    #region Ctors
    public ManualInsDevice(DeviceDefinition i_Definition, DeviceConfig i_Config, ILogService i_LogService) : base(i_Definition, i_Config, i_LogService) { }
    #endregion

    #region Functions
    // Performs Manual-specific connect logic (no IO)
    protected override Task OnConnectAsync() { return Task.CompletedTask; }

    // Performs Manual-specific disconnect logic (no IO)
    protected override Task OnDisconnectAsync() { return Task.CompletedTask; }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Implementations\Tmaps100XInsDevice.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.Devices.Implementations;

// Runtime device implementation for TMaps100X (logic to be added later)
public sealed class Tmaps100XInsDevice : InsDeviceBase
{
    #region Ctors
    public Tmaps100XInsDevice(DeviceDefinition i_Definition, DeviceConfig i_Config, ILogService i_LogService) : base(i_Definition, i_Config, i_LogService) { }
    #endregion

    #region Functions
    // Performs TMaps100X-specific connect logic
    protected override Task OnConnectAsync()
    {
        return Task.CompletedTask;
    }

    // Performs TMaps100X-specific disconnect logic
    protected override Task OnDisconnectAsync()
    {
        return Task.CompletedTask;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Implementations\Vn310InsDevice.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.Devices.Implementations;

// Runtime device implementation for VN310 (logic to be added later)
public sealed class Vn310InsDevice : InsDeviceBase
{
    #region Ctors
    public Vn310InsDevice(DeviceDefinition i_Definition, DeviceConfig i_Config, ILogService i_LogService) : base(i_Definition, i_Config, i_LogService) { }
    #endregion

    #region Functions
    // Performs VN310-specific connect logic
    protected override Task OnConnectAsync()
    {
        return Task.CompletedTask;
    }

    // Performs VN310-specific disconnect logic
    protected override Task OnDisconnectAsync()
    {
        return Task.CompletedTask;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Models\DeviceConfig.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;

namespace NavigationIntegrationSystem.Devices.Models;

// Holds persisted configuration for a single device instance
public sealed class DeviceConfig
{
    #region Properties
    public DeviceType DeviceType { get; set; }
    public bool AutoReconnect { get; set; } = true;
    public DeviceConnectionSettings Connection { get; set; } = new DeviceConnectionSettings();
    #endregion

    #region Functions
    // Copies values from another config (deep)
    public void CopyFrom(DeviceConfig i_Source)
    {
        if (i_Source == null) { return; }

        DeviceType = i_Source.DeviceType;
        AutoReconnect = i_Source.AutoReconnect;

        if (Connection == null) { Connection = new DeviceConnectionSettings(); }

        Connection.CopyFrom(i_Source.Connection);
    }

    // Creates a deep clone of this config
    public DeviceConfig DeepClone()
    {
        var clone = new DeviceConfig();
        clone.CopyFrom(this);
        return clone;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Models\DeviceConnectionSettings.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Devices.Connections;
using NavigationIntegrationSystem.Devices.Enums;

namespace NavigationIntegrationSystem.Devices.Models;

// Holds persisted connection settings for a device (all sections are persisted; Kind selects the active one)
public sealed class DeviceConnectionSettings
{
    #region Properties
    public DeviceConnectionKind Kind { get; set; } = DeviceConnectionKind.Udp;

    public UdpConnectionSettings Udp { get; set; } = new UdpConnectionSettings();
    public TcpConnectionSettings Tcp { get; set; } = new TcpConnectionSettings();
    public SerialConnectionSettings Serial { get; set; } = new SerialConnectionSettings();
    #endregion

    #region Functions
    // Copies values from another connection settings instance (deep)
    public void CopyFrom(DeviceConnectionSettings i_Source)
    {
        if (i_Source == null) { return; }

        Kind = i_Source.Kind;

        if (Udp == null) { Udp = new UdpConnectionSettings(); }
        if (Tcp == null) { Tcp = new TcpConnectionSettings(); }
        if (Serial == null) { Serial = new SerialConnectionSettings(); }

        Udp.CopyFrom(i_Source.Udp);
        Tcp.CopyFrom(i_Source.Tcp);
        Serial.CopyFrom(i_Source.Serial);
    }

    // Creates a deep clone of this instance
    public DeviceConnectionSettings DeepClone()
    {
        var clone = new DeviceConnectionSettings();
        clone.CopyFrom(this);
        return clone;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Modules\IInsDeviceModule.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Runtime;

namespace NavigationIntegrationSystem.Devices.Modules;

// Provides device definition and registers runtime device creation
public interface IInsDeviceModule
{
    #region Properties
    DeviceType Type { get; }
    #endregion

    #region Functions
    // Builds the device catalog definition
    DeviceDefinition BuildDefinition();

    // Registers runtime device creation for this module
    void Register(IInsDeviceRegistry i_Registry, ILogService i_LogService);
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Modules\ManualDeviceModule.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.DeviceCatalog;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Implementations;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Devices.Modules;

// Manual module: definition + runtime registration
public sealed class ManualDeviceModule : IInsDeviceModule
{
    #region Properties
    public DeviceType Type => DeviceType.Manual;
    #endregion

    #region Functions
    // Builds the Manual device definition (no real fields; used as a selectable source)
    public DeviceDefinition BuildDefinition()
    {
        return new DeviceDefinition(
            i_Type: DeviceType.Manual,
            i_Fields: new List<DeviceFieldDefinition>());
    }

    // Registers runtime creation for Manual
    public void Register(IInsDeviceRegistry i_Registry, ILogService i_LogService)
    {
        i_Registry.Register(Type, (DeviceDefinition def, DeviceConfig cfg) => new ManualInsDevice(def, cfg, i_LogService));
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Modules\Tmaps100XDeviceModule.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.DeviceCatalog;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Implementations;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Devices.Modules;

// TMaps100X module: definition + runtime registration
public sealed class Tmaps100XDeviceModule : IInsDeviceModule
{
    #region Properties
    public DeviceType Type => DeviceType.Tmaps100X;
    #endregion

    #region Functions
    // Builds the TMaps100X device definition
    public DeviceDefinition BuildDefinition()
    {
        return new DeviceDefinition(
            i_Type: DeviceType.Tmaps100X,
            i_Fields: new List<DeviceFieldDefinition>
            {
                new("UtcTime", "UTC Time", ""),
                new("LatDeg", "Latitude", "deg"),
                new("LonDeg", "Longitude", "deg"),
                new("AltM", "Altitude", "m"),

                new("AzimuthDeg", "Azimuth", "deg"),
                new DeviceFieldDefinition("PitchDeg", "Pitch", "deg"),
                new DeviceFieldDefinition("RollDeg", "Roll", "deg"),

                new DeviceFieldDefinition("AzimuthRateDegS", "Azimuth Rate", "deg/s"),
                new DeviceFieldDefinition("PitchRateDegS", "Pitch Rate", "deg/s"),
                new DeviceFieldDefinition("RollRateDegS", "Roll Rate", "deg/s"),

                new DeviceFieldDefinition("VelNorth", "Velocity North", "m/s"),
                new DeviceFieldDefinition("VelEast", "Velocity East", "m/s"),
                new DeviceFieldDefinition("VelDown", "Velocity Down", "m/s"),
                new DeviceFieldDefinition("Speed", "Speed", "m/s"),

                new DeviceFieldDefinition("AlignmentState", "Alignment State", ""),
                new DeviceFieldDefinition("GpsStatus", "GPS Status", ""),
                new DeviceFieldDefinition("GeneralStatus", "General Status", "")
            });
    }

    // Registers runtime creation for TMaps100X
    public void Register(IInsDeviceRegistry i_Registry, ILogService i_LogService)
    {
        i_Registry.Register(Type, (DeviceDefinition def, DeviceConfig cfg) => new Tmaps100XInsDevice(def, cfg, i_LogService));
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Modules\Vn310DeviceModule.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.DeviceCatalog;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Implementations;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Devices.Modules;

// VN310 module: definition + runtime registration
public sealed class Vn310DeviceModule : IInsDeviceModule
{
    #region Properties
    public DeviceType Type => DeviceType.VN310;
    #endregion

    #region Functions
    // Builds the VN310 device definition
    public DeviceDefinition BuildDefinition()
    {
        return new DeviceDefinition(
            i_Type: DeviceType.VN310,
            i_Fields: new List<DeviceFieldDefinition>
            {
                new DeviceFieldDefinition("UtcTime", "UTC Time", ""),
                new DeviceFieldDefinition("LatDeg", "Latitude", "deg"),
                new DeviceFieldDefinition("LonDeg", "Longitude", "deg"),
                new DeviceFieldDefinition("AltM", "Altitude", "m"),

                new DeviceFieldDefinition("YawDeg", "Yaw", "deg"),
                new DeviceFieldDefinition("PitchDeg", "Pitch", "deg"),
                new DeviceFieldDefinition("RollDeg", "Roll", "deg"),

                new DeviceFieldDefinition("YawRateDegS", "Yaw Rate", "deg/s"),
                new DeviceFieldDefinition("PitchRateDegS", "Pitch Rate", "deg/s"),
                new DeviceFieldDefinition("RollRateDegS", "Roll Rate", "deg/s"),

                new DeviceFieldDefinition("VelNorth", "Velocity North", "m/s"),
                new DeviceFieldDefinition("VelEast", "Velocity East", "m/s"),
                new DeviceFieldDefinition("VelDown", "Velocity Down", "m/s"),
                new DeviceFieldDefinition("Speed", "Speed", "m/s"),

                new DeviceFieldDefinition("AttUnc", "Att Uncertainty", ""),
                new DeviceFieldDefinition("PosUnc", "Pos Uncertainty", ""),
                new DeviceFieldDefinition("VelUnc", "Vel Uncertainty", ""),

                new DeviceFieldDefinition("InsStatus", "INS Status", ""),
                new DeviceFieldDefinition("TimeStatus", "Time Status", "")
            });
    }

    // Registers runtime creation for VN310
    public void Register(IInsDeviceRegistry i_Registry, ILogService i_LogService)
    {
        i_Registry.Register(Type, (DeviceDefinition def, DeviceConfig cfg) => new Vn310InsDevice(def, cfg, i_LogService));
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Runtime\DevicesModuleBootstrapper.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Devices.Modules;
using System;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Devices.Runtime;

// Bootstraps device modules into the device registry
public sealed class DevicesModuleBootstrapper
{
    #region Ctors
    public DevicesModuleBootstrapper(IEnumerable<IInsDeviceModule> i_Modules, IInsDeviceRegistry i_Registry, ILogService i_LogService)
    {
        var registered = new HashSet<DeviceType>();

        foreach (IInsDeviceModule module in i_Modules)
        {
            if (!registered.Add(module.Type))
            { throw new InvalidOperationException($"Duplicate device module registration: {module.Type}"); }

            module.Register(i_Registry, i_LogService);
        }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Runtime\IInsDeviceRegistry.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;
using System;

namespace NavigationIntegrationSystem.Devices.Runtime;

// Holds runtime creators for each supported device type
public interface IInsDeviceRegistry
{
    #region Functions
    // Registers a device factory for a given device type
    void Register(DeviceType i_Type, Func<DeviceDefinition, DeviceConfig, IInsDevice> i_Factory);

    // Creates a device instance for a given definition/config
    IInsDevice Create(DeviceDefinition i_Definition, DeviceConfig i_Config);
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Runtime\InsDeviceBase.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.Devices.Runtime;

// Implements common runtime behavior for INS devices
public abstract class InsDeviceBase : IInsDevice
{
    #region Private Fields
    private DeviceStatus m_Status;
    private string? m_LastError;
    private CancellationTokenSource? m_ConnectCts;
    private readonly ILogService m_LogService;
    #endregion

    #region Properties
    public DeviceDefinition Definition { get; }
    public DeviceStatus Status => m_Status;
    public string? LastError => m_LastError;
    public DeviceConfig Config { get; }
    #endregion

    #region Events
    public event EventHandler? StateChanged;
    #endregion

    #region Ctors
    protected InsDeviceBase(DeviceDefinition i_Definition, DeviceConfig i_Config, ILogService i_LogService)
    {
        Definition = i_Definition;
        Config = i_Config;
        m_LogService = i_LogService;

        m_Status = DeviceStatus.Disconnected;
        m_LastError = null;
    }
    #endregion

    #region Functions
    // Connects to the device with a simulated connecting delay
    public async Task ConnectAsync()
    {
        if (m_Status == DeviceStatus.Connected || m_Status == DeviceStatus.Connecting)
        { return; }

        m_ConnectCts?.Cancel();
        m_ConnectCts?.Dispose();
        m_ConnectCts = new CancellationTokenSource();

        SetStatus(DeviceStatus.Connecting, null);

        try
        {
            int delayMs = GetConnectDelayMs();
            await Task.Delay(delayMs, m_ConnectCts.Token);

            await OnConnectAsync();
            SetStatus(DeviceStatus.Connected, null);
        }
        catch (OperationCanceledException)
        {
            SetStatus(DeviceStatus.Disconnected, null);
        }
        catch (Exception ex)
        {
            SetStatus(DeviceStatus.Error, ex.Message);
        }
    }

    // Disconnects from the device
    public async Task DisconnectAsync()
    {
        if (m_Status == DeviceStatus.Disconnected)
        { return; }

        m_ConnectCts?.Cancel();
        m_ConnectCts?.Dispose();
        m_ConnectCts = null;

        try
        {
            await OnDisconnectAsync();
            SetStatus(DeviceStatus.Disconnected, null);
        }
        catch (Exception ex)
        {
            SetStatus(DeviceStatus.Error, ex.Message);
        }
    }

    // Updates status and notifies listeners
    protected void SetStatus(DeviceStatus i_Status, string? i_Error)
    {
        if (m_Status == i_Status)
        { return; }

        m_Status = i_Status;
        m_LastError = i_Error;

        switch (i_Status)
        {
            case DeviceStatus.Connected:
                m_LogService.Info(nameof(InsDeviceBase), $"{Definition.DisplayName} connected successfully");
                break;

            case DeviceStatus.Disconnected:
                m_LogService.Info(nameof(InsDeviceBase), $"{Definition.DisplayName} disconnected");
                break;

            case DeviceStatus.Connecting:
                m_LogService.Info(nameof(InsDeviceBase), $"{Definition.DisplayName} connecting...");
                break;

            case DeviceStatus.Error:
                m_LogService.Error(nameof(InsDeviceBase), $"{Definition.DisplayName} error: {i_Error}");
                break;
        }

        StateChanged?.Invoke(this, EventArgs.Empty);
    }

    // Returns a connect delay (1–2 seconds)
    protected virtual int GetConnectDelayMs() { return 1000 + Random.Shared.Next(0, 1001); }

    // Performs device-specific connect logic
    protected abstract Task OnConnectAsync();

    // Performs device-specific disconnect logic
    protected abstract Task OnDisconnectAsync();
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Runtime\InsDeviceRegistry.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Models;

using System;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Devices.Runtime;

// Dictionary-based registry for device creation and session-stable ID management
public sealed class InsDeviceRegistry : IInsDeviceRegistry, IInsDeviceInstanceProvider
{
    #region Private Fields
    private readonly Dictionary<DeviceType, Func<DeviceDefinition, DeviceConfig, IInsDevice>> m_Factories = new();
    private readonly Dictionary<DeviceType, ushort> m_TypeCounters = new();
    private readonly Dictionary<IInsDevice, ushort> m_AssignedIds = new();
    private readonly object m_Lock = new();
    #endregion

    #region Functions
    // Registers a device factory for a given device type
    public void Register(DeviceType i_Type, Func<DeviceDefinition, DeviceConfig, IInsDevice> i_Factory)
    {
        m_Factories[i_Type] = i_Factory;
    }

    // Creates a device instance and assigns it a stable session ID
    public IInsDevice Create(DeviceDefinition i_Definition, DeviceConfig i_Config)
    {
        if (!m_Factories.TryGetValue(i_Definition.Type, out var factory))
        {
            throw new NotSupportedException($"Unsupported device type: {i_Definition.Type}");
        }

        IInsDevice device = factory(i_Definition, i_Config);

        lock (m_Lock)
        {
            if (!m_TypeCounters.TryGetValue(i_Definition.Type, out ushort currentCount))
            {
                currentCount = 0;
            }

            m_AssignedIds[device] = currentCount;
            m_TypeCounters[i_Definition.Type] = (ushort)(currentCount + 1);
        }

        return device;
    }

    // Retrieves the assigned ID for an existing device instance
    public ushort GetInstanceId(IInsDevice i_Device)
    {
        lock (m_Lock)
        {
            return m_AssignedIds.TryGetValue(i_Device, out ushort id) ? id : (ushort)0;
        }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Devices\Validation\ConnectionSettingsValidator.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Devices.Enums;
using NavigationIntegrationSystem.Devices.Models;
using System.Collections.Generic;
using System.Globalization;

namespace NavigationIntegrationSystem.Devices.Validation;

// Validates connection settings for a device and returns user-friendly errors
public static class ConnectionSettingsValidator
{
    #region Functions
    // Validates a DeviceConnectionSettings instance and returns a list of validation errors
    public static IReadOnlyList<string> Validate(DeviceConnectionSettings i_Settings)
    {
        var errors = new List<string>();

        if (i_Settings == null) { errors.Add("Connection settings are missing"); return errors; }

        switch (i_Settings.Kind)
        {
            case DeviceConnectionKind.Udp:
                ValidateUdp(i_Settings, errors);
                break;

            case DeviceConnectionKind.Tcp:
                ValidateTcp(i_Settings, errors);
                break;

            case DeviceConnectionKind.Serial:
                ValidateSerial(i_Settings, errors);
                break;

            default:
                errors.Add("Unsupported connection kind");
                break;
        }

        return errors;
    }
    #endregion

    #region Private Functions
    // Validates UDP settings
    private static void ValidateUdp(DeviceConnectionSettings i_Settings, List<string> io_Errors)
    {
        if (i_Settings.Udp == null) { io_Errors.Add("UDP settings are missing"); return; }

        if (!IsIpValid(i_Settings.Udp.RemoteIp)) { io_Errors.Add($"UDP remote IP is invalid: '{i_Settings.Udp.RemoteIp}'"); }
        if (!IsIpValid(i_Settings.Udp.LocalIp)) { io_Errors.Add($"UDP local IP is invalid: '{i_Settings.Udp.LocalIp}'"); }

        if (!IsPortValid(i_Settings.Udp.RemotePort)) { io_Errors.Add($"UDP remote port must be between 1 and 65535: {i_Settings.Udp.RemotePort}"); }
        if (!IsPortValid(i_Settings.Udp.LocalPort)) { io_Errors.Add($"UDP local port must be between 1 and 65535: {i_Settings.Udp.LocalPort}"); }
    }

    // Validates TCP settings
    private static void ValidateTcp(DeviceConnectionSettings i_Settings, List<string> io_Errors)
    {
        if (i_Settings.Tcp == null) { io_Errors.Add("TCP settings are missing"); return; }

        if (!IsIpValid(i_Settings.Tcp.Host)) { io_Errors.Add($"TCP Host IP is invalid: '{i_Settings.Tcp.Host}'"); }

        if (!IsPortValid(i_Settings.Tcp.Port)) { io_Errors.Add($"TCP port must be between 1 and 65535: {i_Settings.Tcp.Port}"); }
    }

    // Validates Serial settings
    private static void ValidateSerial(DeviceConnectionSettings i_Settings, List<string> io_Errors)
    {
        if (i_Settings.Serial == null) { io_Errors.Add("Serial settings are missing"); return; }

        if (string.IsNullOrWhiteSpace(i_Settings.Serial.ComPort)) { io_Errors.Add($"Serial COM port is required: '{i_Settings.Serial.ComPort}'"); }
        if (i_Settings.Serial.BaudRate <= 0) { io_Errors.Add($"Serial baud rate must be greater than 0: {i_Settings.Serial.BaudRate}"); }
    }

    // Checks whether an integer is a valid TCP/UDP port number
    private static bool IsPortValid(int i_Port)
    {
        return i_Port >= 1 && i_Port <= 65535;
    }

    // Checks whether a string is a strict IPv4 dotted-quad with each octet 0..255
    private static bool IsIpValid(string i_Ip)
    {
        if (string.IsNullOrWhiteSpace(i_Ip)) { return false; }

        string[] parts = i_Ip.Trim().Split('.');
        if (parts.Length != 4) { return false; }

        for (int i = 0; i < 4; i++)
        {
            if (!int.TryParse(parts[i], NumberStyles.None, CultureInfo.InvariantCulture, out int octet)) { return false; }
            if (octet < 0 || octet > 255) { return false; }
        }

        return true;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\NavigationIntegrationSystem.Infrastructure.csproj
// ---------------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
	  <TargetFramework>net8.0</TargetFramework>
	  <RootNamespace>NavigationIntegrationSystem.Infrastructure</RootNamespace>
	  <Nullable>enable</Nullable>
	  <Platforms>AnyCPU;x64</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\NavigationIntegrationSystem.Core\NavigationIntegrationSystem.Core.csproj" />
    <ProjectReference Include="..\NavigationIntegrationSystem.Devices\NavigationIntegrationSystem.Devices.csproj" />
  </ItemGroup>
</Project>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Configuration\Paths\AppPaths.cs
// ---------------------------------------------------------

using System;
using System.IO;

namespace NavigationIntegrationSystem.Infrastructure.Configuration.Paths;

// Centralizes application file paths under the output directory
public static class AppPaths
{
    #region Properties
    public static string BaseDirectory => AppContext.BaseDirectory.TrimEnd('\\');
    public static string ConfigDirectory => Path.Combine(BaseDirectory, "Config");
    public static string DevicesConfigPath => Path.Combine(ConfigDirectory, "devices.json");
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Configuration\Paths\PathResolver.cs
// ---------------------------------------------------------

using System;

namespace NavigationIntegrationSystem.Infrastructure.Configuration.Paths;

// Resolves special path tokens like {BaseDirectory} to runtime paths
public static class PathResolver
{
    // Expands supported tokens into concrete runtime paths
    public static string Resolve(string i_Path)
    {
        string baseDir = AppContext.BaseDirectory.TrimEnd('\\');

        if (string.IsNullOrWhiteSpace(i_Path)) { return baseDir; }

        return i_Path.Replace("{BaseDirectory}", baseDir);
    }

}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Configuration\Settings\AppSettings.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Infrastructure.Configuration.Settings;

// Holds strongly-typed settings loaded from appsettings.json
public sealed class AppSettings
{
    public NisSettings Nis { get; set; } = new NisSettings();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Configuration\Settings\LogSettings.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Infrastructure.Configuration.Settings;

// Holds log settings such as file path and UI buffer limits
public sealed class LogSettings
{
    public string Root { get; set; } = "{BaseDirectory}\\Logs";
    public int MaxUiEntries { get; set; } = 2000;
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Configuration\Settings\NisSettings.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Infrastructure.Configuration.Settings;

// Holds application-wide settings for NIS
public sealed class NisSettings
{
    public LogSettings Log { get; set; } = new LogSettings();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Logging\FileLogService.cs
// ---------------------------------------------------------

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using NavigationIntegrationSystem.Core.Logging;

namespace NavigationIntegrationSystem.Infrastructure.Logging;

// Writes logs to file and broadcasts log records to listeners
public sealed class FileLogService : ILogService, ILogPaths
{
    #region Private Fields
    private readonly SemaphoreSlim m_FileLock = new SemaphoreSlim(1, 1);
    private readonly string m_LogFolderPath;
    #endregion

    #region Properties
    public string LogFolderPath => m_LogFolderPath;
    #endregion

    #region Events
    public event Action<LogRecord>? RecordWritten;
    #endregion

    #region Ctors
    public FileLogService(string i_LogFolderPath)
    {
        m_LogFolderPath = i_LogFolderPath;
        Directory.CreateDirectory(m_LogFolderPath);
    }
    #endregion

    #region Functions
    // Logs a debug message
    public void Debug(string i_Source, string i_Message) { Write(LogLevel.Debug, i_Source, i_Message, null); }

    // Logs an informational message
    public void Info(string i_Source, string i_Message) { Write(LogLevel.Info, i_Source, i_Message, null); }

    // Logs a warning message
    public void Warn(string i_Source, string i_Message) { Write(LogLevel.Warn, i_Source, i_Message, null); }

    // Logs an error message
    public void Error(string i_Source, string i_Message, Exception? i_Exception = null)
    {
        Write(LogLevel.Error, i_Source, i_Message, i_Exception?.ToString());
    }

    // Creates a record, broadcasts it, and persists to disk
    private void Write(LogLevel i_Level, string i_Source, string i_Message, string? i_ExceptionText)
    {
        var record = new LogRecord(DateTime.UtcNow, i_Level, i_Source, i_Message, i_ExceptionText);

        RecordWritten?.Invoke(record);
        _ = WriteToFileAsync(record);
    }

    // Writes the record to the current daily log file
    private async Task WriteToFileAsync(LogRecord i_Record)
    {
        string filePath = Path.Combine(m_LogFolderPath, $"{DateTime.UtcNow:yyyy-MM-dd}.log");
        string level = i_Record.Level.ToString().ToUpperInvariant();

        string line = $"{i_Record.TimestampUtc:yyyy-MM-dd HH:mm:ss.fff}Z [{level}] {i_Record.Source} - {i_Record.Message}";
        if (!string.IsNullOrWhiteSpace(i_Record.ExceptionText)) { line = $"{line}{Environment.NewLine}{i_Record.ExceptionText}"; }
        line = $"{line}{Environment.NewLine}";

        await m_FileLock.WaitAsync().ConfigureAwait(false);
        try { await File.AppendAllTextAsync(filePath, line, Encoding.UTF8).ConfigureAwait(false); }
        finally { m_FileLock.Release(); }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Persistence\DevicesConfig\DevicesConfigFile.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Devices.Models;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Infrastructure.Persistence.DevicesConfig;

// Represents the root structure saved to devices.json
public sealed class DevicesConfigFile
{
    #region Properties
    public List<DeviceConfig> Devices { get; set; } = new List<DeviceConfig>();
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Persistence\DevicesConfig\DevicesConfigService.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Devices.Models;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace NavigationIntegrationSystem.Infrastructure.Persistence.DevicesConfig;

// Loads and saves devices.json configuration for the fixed device instances
public sealed class DevicesConfigService
{
    #region Private Fields
    private readonly string m_ConfigFilePath;
    private readonly JsonSerializerOptions m_JsonOptions;
    #endregion

    #region Ctors
    public DevicesConfigService(string i_ConfigFilePath)
    {
        m_ConfigFilePath = i_ConfigFilePath;

        m_JsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            Converters = { new JsonStringEnumConverter() }
        };
    }
    #endregion

    #region Functions
    // Loads devices configuration from disk or returns an empty config if missing
    public DevicesConfigFile Load()
    {
        if (!File.Exists(m_ConfigFilePath)) { return new DevicesConfigFile(); }

        string json = File.ReadAllText(m_ConfigFilePath);
        DevicesConfigFile? config = JsonSerializer.Deserialize<DevicesConfigFile>(json, m_JsonOptions);
        return config ?? new DevicesConfigFile();
    }

    // Saves devices configuration to disk
    public void Save(DevicesConfigFile i_Config)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(m_ConfigFilePath)!);
        string json = JsonSerializer.Serialize(i_Config, m_JsonOptions);
        File.WriteAllText(m_ConfigFilePath, json);
    }

    // Gets an existing config for deviceId or creates a default one
    public DeviceConfig GetOrCreateDevice(DevicesConfigFile i_Config, DeviceType i_DeviceType)
    {
        DeviceConfig? existing = i_Config.Devices.FirstOrDefault(d => d.DeviceType == i_DeviceType);
        if (existing != null) { return existing; }

        var created = new DeviceConfig { DeviceType = i_DeviceType, AutoReconnect = true, Connection = new DeviceConnectionSettings() };
        i_Config.Devices.Add(created);
        return created;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\DataRecordHeader.cs
// ---------------------------------------------------------

namespace Infrastructure.FileManagement.DataRecording
{
    public class DataRecordHeader
    {
        private const ushort m_Sync = 0x7E55;

        public ushort SyncWord => m_Sync;
        public ushort ID { get; set; }
        public ushort DataType { get; set; }
        public ushort DataLength { get; set; }
        public long Time { get; set; }

        public int HeaderLength => (4 * sizeof(ushort) + sizeof(long));

        public DataRecordHeader() { }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\DataRecordType.cs
// ---------------------------------------------------------

using System;
using System.Collections.Generic;

namespace NavigationIntegrationSystem.Infrastructure.Recording;

public class RecordTypeItem : ViewModelBase
{
    public string recordTypeName { get; set; } = string.Empty;
    public List<RecordIDItem> recordIDs { get; set; }
    public bool isChecked { get; set; }
    public List<RecordFieldItem> recordFields { get; set; }
    public Dictionary<string, string> dict { get; set; } = new();

    public RecordTypeItem()
    {
        recordIDs = new List<RecordIDItem>();
        recordFields = new List<RecordFieldItem>();
        isChecked = true;
        // dict initialized inline above
    }

    private string[] columnsNames { get; set; } = Array.Empty<string>();

    public string[] ColumnsNames
    {
        get { return columnsNames; }
        set
        {
            columnsNames = value ?? Array.Empty<string>();
            foreach (string name in columnsNames)
            {
                recordFields.Add(new RecordFieldItem() { recordFieldName = name });
            }
        }
    }

    public RecordTypeItem Clone()
    {
        return (RecordTypeItem)MemberwiseClone();
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\NisRecordingService.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.Infrastructure\Recording\NisRecordingService.cs
using System;
using System.IO;
using System.Threading;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Recording;
using Infrastructure.FileManagement.DataRecording;
using Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;
using Infrastructure.Templates;
using log4net;

namespace NavigationIntegrationSystem.Infrastructure.Recording;

public sealed class NisRecordingService : IRecordingService
{
    #region Constants
    private const int c_IntegratedOutputRecordType = 50;
    private const int c_IntegratedOutputRecordId = 0;
    private const int c_LegacyBufferSize = 1024;
    #endregion

    #region Private Fields
    private readonly BinaryFileRecorderEnhanced m_Recorder;
    private readonly ILogService m_LogService;
    private readonly object m_Lock = new();
    private byte[] m_EncodeBuffer;
    #endregion

    #region Properties
    public bool IsRecording => m_Recorder.isRecording;
    #endregion

    #region Events
    public event EventHandler<bool>? RecordingStateChanged;
    #endregion

    #region Constructors
    public NisRecordingService(ILogService i_LogService, ILogPaths i_LogPaths)
    {
        m_LogService = i_LogService;
        m_EncodeBuffer = new byte[c_LegacyBufferSize];

        m_Recorder = Singleton<BinaryFileRecorderEnhanced>.Instance;
        m_Recorder.Logger = new Log4NetAdapter(i_LogService, "BinaryFileRecorder");

        string baseDir = AppDomain.CurrentDomain.BaseDirectory.TrimEnd('\\');
        string recPath = Path.Combine(baseDir, "Recordings");
        m_Recorder.SetRecordingDirectory(recPath);

        m_Recorder.RecordingStartStop += (isRec) => RecordingStateChanged?.Invoke(this, isRec);
    }
    #endregion

    #region Functions
    // Starts recording and immediately writes a "Fill" record to prevent 0-byte deletion
    public void Start()
    {
        lock (m_Lock)
        {
            if (IsRecording) return;

            string result = m_Recorder.StartRecording();
            if (string.IsNullOrEmpty(result))
            {
                // IMMEDIATELY write a dummy record to increment m_CurrentFileSize
                // This ensures the legacy CloseCurrentFile never sees a 0 size.
                m_Recorder.Record(99, 99, new byte[1], 1, DateTime.UtcNow);
                m_LogService.Info(nameof(NisRecordingService), "Recording started with persistence fill.");
            }
            else
            {
                m_LogService.Error(nameof(NisRecordingService), $"Start failed: {result}");
            }
        }
    }

    // Flushes and stops the recording
    public void Stop()
    {
        lock (m_Lock)
        {
            if (!IsRecording) return;

            // FORCE a flush using the legacy periodic logic
            // This triggers m_File.Flush() inside the legacy class
            m_Recorder.OnPeriodicOnePps(this, EventArgs.Empty);

            // Give the OS a moment to finish the Async Write
            Thread.Sleep(50);

            m_Recorder.StopRecording();
            m_LogService.Info(nameof(NisRecordingService), "Recording stopped and flushed.");
        }
    }

    // Records live snapshots
    public void RecordIntegratedOutput(object i_DataSnapshot)
    {
        if (!IsRecording || i_DataSnapshot is not IntegratedInsOutput_Data data) return;

        lock (m_Lock)
        {
            int size = 0;
            EncodeDataToBuffer(data, ref m_EncodeBuffer, ref size);

            if (size > 0)
            {
                bool success = m_Recorder.Record(
                    c_IntegratedOutputRecordId,
                    c_IntegratedOutputRecordType,
                    m_EncodeBuffer,
                    size,
                    DateTime.UtcNow);

                // Periodic flush to keep the file size updated on disk
                // We do this every record for safety in NIS (usually 50Hz)
                if (success)
                {
                    m_Recorder.OnPeriodicOnePps(this, EventArgs.Empty);
                }
            }
        }
    }

    // Manual encoding for VIC protocol [Sync][Payload][Checksum]
    private void EncodeDataToBuffer(IntegratedInsOutput_Data i_Data, ref byte[] io_Buffer, ref int io_Size)
    {
        // Clear buffer to ensure no trailing garbage
        Array.Clear(io_Buffer, 0, io_Buffer.Length);

        using (MemoryStream ms = new MemoryStream(io_Buffer))
        using (BinaryWriter writer = new BinaryWriter(ms))
        {
            writer.Write((byte)0x50);
            i_Data.Encode(writer);
            writer.Write((byte)0);
        }

        int totalLen = IntegratedInsOutput_Data.BinLength + 2;
        byte checksum = 0;
        for (int i = 1; i < totalLen - 1; i++)
        {
            checksum += io_Buffer[i];
        }

        io_Buffer[totalLen - 1] = checksum;
        io_Size = totalLen;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\RecordFieldItem.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.Infrastructure.Recording;

public class RecordFieldItem : ViewModelBase
{
    public string recordFieldName { get; set; } = string.Empty;

    public RecordFieldItem()
    {
        isChecked = true;
    }

    private bool isChecked;

    public bool IsChecked
    {
        get { return isChecked; }
        set
        {
            isChecked = value;
            OnPropertyChanged();
        }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\RecordIDItem.cs
// ---------------------------------------------------------

using System.IO;

namespace NavigationIntegrationSystem.Infrastructure.Recording;

public class RecordIDItem
{
    public string recordIDName { get; set; } = string.Empty;
    public bool isChecked { get; set; }
    public string rawDataLine { get; set; } = string.Empty;

    // Changed to nullable as a file might not be open at instantiation
    public StreamWriter? rawDataFile { get; set; }

    public RecordIDItem()
    {
        isChecked = true;
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\Recording\ViewModelBase.cs
// ---------------------------------------------------------

using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace NavigationIntegrationSystem.Infrastructure.Recording;

public class ViewModelBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    protected void OnPropertyChanged([CallerMemberName] string? name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }

    protected bool SetPropertyIfChanged<T>(ref T field, T value, [CallerMemberName] string propertyName = "")
    {
        if (!EqualityComparer<T>.Default.Equals(field, value))
        {
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }

        return false;
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\BinaryDataDecodingStatus.cs
// ---------------------------------------------------------

namespace Infrastructure.Enums
{
    public enum BinaryDataDecodingStatus
    {
        LengthError = 0,
        ChecksumError,
        SyncError,
        Success,
        OtherError,
        Irrelevant
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\BinaryFileRecorderEnhanced.cs
// ---------------------------------------------------------

using Infrastructure.FileManagement.Settings;

using log4net;

using System;
using System.IO;

namespace Infrastructure.FileManagement.DataRecording
{
    public class BinaryFileRecorderEnhanced
    {
        #region Parameters
        private const long MinimumFreeSpaceRequiredToStartRecording = 10000000; //in bytes = 10mb
        private const double MinimumFreeSpaceRequiredToStartRecordingInMb = MinimumFreeSpaceRequiredToStartRecording / 1048576.0;
        private const string FilenameExtension = ".dat";
        private object m_LockObject;
        private ILog m_logger;
        private string m_Filename;
        private string m_Pathname;
        private string m_FilenameTitle;
        private string m_RecordingDirectory;
        private bool m_isRecording;
        private ulong m_CurrentFileSize;
        private FileStream m_File;
        private MemoryStream m_MemStream;
        private BinaryWriter m_BinWriter;
        private byte[] m_WriteBuffer;
        private const int m_BufferSize = 1024;
        private DataRecordHeader m_Header;
        private DriveInfo recordDriveInfo;
        private RecordStatistics recordStatistics;
        #endregion  // Parameters

        #region Properties
        public RecordingSettings Settings { get; set; }
        public int SelectedScenrarioIndex { get; private set; }
        public RecordStatistics RecordStatistics
        {
            private set => recordStatistics = value;
            get { return recordStatistics.Clone(); }
        }
        public string Filename
        {
            get { return m_Filename; }
        }

        public string Pathname
        {
            get { return m_Pathname; }
        }

        public ulong Filesize
        {
            get { return m_CurrentFileSize; }
        }

        public bool isRecording
        {
            get { return m_isRecording; }
        }


        public ILog Logger
        {
            set
            {
                lock (m_LockObject)
                {
                    m_logger = value;
                }
            }
        }

        public bool IsRecordingDirectoryAUncPath { get; set; }

        /// <summary>
        /// for unc path there is no way to know the drive letter of the recording path.
        /// thus, no free space check can be made.
        /// use this property to force a disk space check in a certain drive like c: or d:
        /// leave this empty and the recorder will try to get the drive letter from the recording directory (it is not unc)
        /// </summary>
        public string ForceDriveLetterFreeSpaceCheck { get; set; }


        #endregion        // Properties

        public event Action<string> ErrorOccuredDuringRecording;

        /// <summary>
        /// updates subscribers once per seconds about record statistics
        /// </summary>
        public event Action<RecordStatistics> RecordStatisticsUpdate;
        public event Action<bool> RecordingStartStop;

        #region Construcrtor
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="logService"></param>
        /// <param name="settings"></param>
        /// <param name="recordingPath"></param>
        public BinaryFileRecorderEnhanced()
        {
            m_LockObject = new object();
            ForceDriveLetterFreeSpaceCheck = string.Empty;
            IsRecordingDirectoryAUncPath = false;
            m_logger = null;
            m_Pathname = string.Empty;
            m_Filename = "";
            m_FilenameTitle = "Scenario";
            m_RecordingDirectory = string.Empty;
            m_isRecording = false;
            m_CurrentFileSize = 0;

            Settings = new RecordingSettings();
            Settings.LoadDefaultSettings();
            m_File = null;

            m_WriteBuffer = new byte[m_BufferSize];
            m_MemStream = new MemoryStream(m_WriteBuffer);
            m_BinWriter = new BinaryWriter(m_MemStream);
            m_BinWriter.Seek(0, SeekOrigin.Begin);

            m_Header = new DataRecordHeader();

            recordStatistics = new RecordStatistics();
            SelectedScenrarioIndex = 0;
        }

        #endregion  // Construcrtor


        #region Methods

        private void CloseCurrentFile()
        {
            if (m_File != null)
            {
                try
                {
                    m_File.Flush();
                    m_File.Close();

                    string str = "DataRecorder: Closed Recording file " + m_Filename;
                    if (m_logger != null)
                        m_logger.Info(str);

                    if (m_CurrentFileSize == 0)
                    {
                        File.Delete(m_Pathname);
                        str = "DataRecorder: deleted Recording file " + m_Filename + " (due to 0 file size)";
                        if (m_logger != null)
                            m_logger.Info(str);
                    }
                }
                catch (Exception e)
                {
                    if (m_logger != null)
                        m_logger.Error($"Error while closing binary file {m_Filename}.", e);
                }
                finally
                {
                    m_File = null;
                }
            }
        }

        /// <summary>
        /// replace the recording directory to a new one
        /// </summary>
        /// <param name="newDir"></param>
        public void SetRecordingDirectory(string newDir)
        {
            if (!m_isRecording)
            {
                m_RecordingDirectory = newDir;
            }
        }

        public void SelectScenario(byte scenarioID)
        {
            if ((scenarioID >= 0) && (Settings.ScenariosList.Count > scenarioID))
            {
                SelectedScenrarioIndex = scenarioID;
            }
        }

        public string ToggleRecordingCommand()
        {
            if (m_isRecording)
            {
                StopRecording();
                return "";
            }
            else
            {
                return StartRecording();
            }
        }

        /// <returns>empty string if success, otherwise returns error message</returns>
        public string StartRecording()
        {
            try
            {
                if (m_isRecording)
                {
                    m_logger?.Info("Start recording requested while recording is in progress");
                    return "Recording is already in progress!";
                }

                if (m_RecordingDirectory == string.Empty)
                {
                    string error = "Recording Directory is an empty string.";
                    m_logger.Error("Cannot Start recording. " + error);
                    return error;
                }
                Directory.CreateDirectory(m_RecordingDirectory);

                recordDriveInfo = null;

                if (IsRecordingDirectoryAUncPath)
                {
                    if (ForceDriveLetterFreeSpaceCheck != string.Empty)
                    {
                        recordDriveInfo = new DriveInfo(ForceDriveLetterFreeSpaceCheck);
                        if (recordDriveInfo == null)
                        {
                            string error = "Error retrieving recording drive info, cannot check for free space.";
                            m_logger?.Error("Cannot Start recording. " + error);
                            return error;
                        }
                    }
                }
                else
                {
                    recordDriveInfo = new DriveInfo(Path.GetPathRoot(m_RecordingDirectory));
                    if (recordDriveInfo == null)
                    {
                        string error = "Error retrieving recording drive info, cannot check for free space.";
                        m_logger?.Error("Cannot Start recording. " + error);
                        return error;
                    }
                }

                if (recordDriveInfo != null)
                {
                    if (recordDriveInfo.AvailableFreeSpace < MinimumFreeSpaceRequiredToStartRecording)
                    {
                        string error = $"Not enough free space is available for recording in {recordDriveInfo.Name} drive. Minimum required : {MinimumFreeSpaceRequiredToStartRecordingInMb.ToString("F2")} Mb.";
                        m_logger.Error("Cannot Start recording. " + error);
                        return error;
                    }
                }


                DateTime now;
                string str = "Scenario";

                //build new filename:

                if (Settings.ScenariosList.Count > 0)
                {
                    m_FilenameTitle = Settings.ScenariosList[SelectedScenrarioIndex];
                }

                now = DateTime.UtcNow;
                str = now.Year.ToString("0000");
                str += now.Month.ToString("00");
                str += now.Day.ToString("00");
                str += "_";
                str += now.Hour.ToString("00");
                str += now.Minute.ToString("00");
                str += now.Second.ToString("00");
                m_Filename = m_FilenameTitle + "_" + str + FilenameExtension;
                m_Pathname = m_RecordingDirectory + "\\" + m_Filename;

                recordStatistics.StartTime = now;

                m_File = new FileStream(
                   m_Pathname,
                   System.IO.FileMode.CreateNew,
                   System.IO.FileAccess.Write,
                   System.IO.FileShare.None,
                   65536,
                   System.IO.FileOptions.Asynchronous);
                m_CurrentFileSize = 0;

                lock (m_LockObject)
                {
                    m_isRecording = true;
                }

                m_logger?.Info("Recording started. Opened file " + m_Filename);
                RecordingStartStop?.Invoke(true);
                return string.Empty;
            }
            catch (Exception e)
            {
                string errorMsg = "Error while trying to initiate recording session.";
                m_logger?.Error(errorMsg, e);
                errorMsg += Environment.NewLine + e.Message;
                return errorMsg;
            }
        }

        public void StopRecording()
        {
            if (m_isRecording)
            {
                lock (m_LockObject)
                {
                    m_isRecording = false;
                    CloseCurrentFile();
                    m_Filename = "";
                    RecordingStartStop?.Invoke(false);
                }

                m_logger?.Info("Data Recorder: Stopped Data Recording");
            }
        }

        /// <summary>
        /// Records an input data buffer to file.
        /// using Asynchronous IO Operation,
        /// </summary>
        /// <param name="id"></param>
        /// <param name="inData"></param>
        /// <param name="dataSize"></param>
        /// <param name="now"></param>
        /// <returns></returns>
        public bool Record(int id, int type, byte[] inData, long dataSize, DateTime now)
        {
            bool success = false;

            if (dataSize > m_BufferSize)
                return success;

            lock (m_LockObject)
            {
                if (m_isRecording)
                {
                    try
                    {
                        m_Header.ID = (ushort)id;
                        m_Header.DataType = (ushort)type;
                        m_Header.DataLength = (ushort)dataSize;
                        m_Header.Time = now.ToBinary();
                        m_BinWriter.Seek(0, SeekOrigin.Begin);
                        m_BinWriter.Write(m_Header.SyncWord);
                        m_BinWriter.Write(m_Header.ID);
                        m_BinWriter.Write(m_Header.DataLength);
                        m_BinWriter.Write(m_Header.Time);
                        m_BinWriter.Write(m_Header.DataType);
                        m_BinWriter.Write(inData, 0, (int)dataSize);
                        m_File.WriteAsync(m_MemStream.ToArray(), 0, m_Header.HeaderLength + (int)dataSize);
                        m_CurrentFileSize += (ulong)(m_Header.HeaderLength + dataSize);
                        success = true;
                    }
                    catch (Exception e)
                    {
                        m_logger?.Error("Error occured during recording. stopping recording...", e);
                        StopRecording();
                    }
                }
            }

            return success;
        }

        public void OnPeriodicOnePps(object sender, EventArgs e)
        {
            lock (m_LockObject)
            {
                if (m_isRecording)
                {
                    // check for maximum file size:
                    if (m_CurrentFileSize >= Settings.MaximumFileSize)
                    {
                        m_logger?.Info("DataRecorder: Creating New File, Max size Exceeded.");
                        StopRecording();
                        StartRecording();
                        return;
                    }
                    else
                    {
                        try
                        {
                            m_File.Flush();
                        }
                        catch (Exception ex)
                        {
                            StopRecording();
                            m_logger?.Error("Error occured during flush record operation. stopping recording...", ex);
                            ErrorOccuredDuringRecording?.Invoke(ex.Message);

                            return;
                        }
                    }


                    if (recordDriveInfo != null)
                    {
                        if (recordDriveInfo.AvailableFreeSpace < MinimumFreeSpaceRequiredToStartRecording)
                        {
                            StopRecording();
                            m_logger?.Error("Error occured during recording. Not enough free space is available for recording. stopping recording...");
                            ErrorOccuredDuringRecording?.Invoke($"Not enough free space is available for recording in {recordDriveInfo.Name} drive.\nMinimum required : {MinimumFreeSpaceRequiredToStartRecordingInMb.ToString("F2")} Mb.");
                            return;
                        }

                        recordStatistics.RecordingDiskTotalSize = recordDriveInfo.TotalSize;
                        recordStatistics.RecordingDiskFreeSpace = recordDriveInfo.AvailableFreeSpace;
                    }


                    try
                    {
                        FileInfo fi = new FileInfo(m_Pathname);

                        recordStatistics.Elapsed = DateTime.UtcNow - recordStatistics.StartTime;
                        recordStatistics.FileSizeBytes = fi.Length;
                    }
                    catch (Exception er)
                    {
                        StopRecording();
                        m_logger.Error($"Binary file recorder OnPeriodicOnePps FileInfo exception", er);
                        ErrorOccuredDuringRecording?.Invoke("Error retrieving file info :" + Environment.NewLine + er.Message);
                        return;
                    }

                    RecordStatisticsUpdate?.Invoke(recordStatistics.Clone());
                }
            }
        }

        #endregion   // Methods
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\DomainTimeWrapper64.cs
// ---------------------------------------------------------

namespace DomainTimeWrapper64
{

}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\EulerAngles.cs
// ---------------------------------------------------------

using Infrastructure.Serialization;
using Infrastructure.Tools;
using System;
using System.IO;
using System.Runtime.Serialization;

namespace Infrastructure.Navigation.EulerCalculations
{
    public class EulerAngles
    {
        public double Yaw { get; set; }
        public double Pitch { get; set; }
        public double Roll { get; set; }

        public static int BinLength
        {
            get
            {
                return 3 * sizeof(UInt32);
            }
        }

        public bool IsClear => (Yaw == 0) && (Pitch == 0) && (Roll == 0);

        public void Clear()
        {
            Yaw = Pitch = Roll = 0.0;
        }

        public EulerAngles Clone()
        {
            return (EulerAngles)this.MemberwiseClone();
        }


        public EulerAngles()
        {
            Clear();
        }

        public EulerAngles(double y, double p, double r)
        {
            Yaw = y;
            Pitch = p;
            Roll = r;
        }

        public void ConvertToRadians()
        {
            Yaw *= Constants.DegToRadRatio;
            Pitch *= Constants.DegToRadRatio;
            Roll *= Constants.DegToRadRatio;
        }

        public void ConvertToDegrees()
        {
            Yaw *= Constants.RadToDegRatio;
            Pitch *= Constants.RadToDegRatio;
            Roll *= Constants.RadToDegRatio;
        }
        /// <summary>
        /// Decode Constructor
        /// </summary>
        /// <param name="reader"></param>
        public EulerAngles(BinaryReader reader, Coding type = Coding.Angle)
        {
            switch (type)
            {
                case Coding.Angle:
                    Yaw = CommunicationBase.DecodeAngle(reader);
                    Pitch = CommunicationBase.DecodeAngle(reader);
                    Roll = CommunicationBase.DecodeAngle(reader);
                    break;
                case Coding.Motion:
                    Yaw = CommunicationBase.DecodeMotion(reader);
                    Pitch = CommunicationBase.DecodeMotion(reader);
                    Roll = CommunicationBase.DecodeMotion(reader);
                    break;
                case Coding.General:
                    Yaw = CommunicationBase.DecodeGeneralDoubleValue(reader);
                    Pitch = CommunicationBase.DecodeGeneralDoubleValue(reader);
                    Roll = CommunicationBase.DecodeGeneralDoubleValue(reader);
                    break;
                default:
                    break;
            }
        }

        public void Encode(BinaryWriter writer, Coding type = Coding.Angle)
        {
            switch (type)
            {
                case Coding.Angle:
                    writer.Write(CommunicationBase.EncodeAngle(Yaw));
                    writer.Write(CommunicationBase.EncodeAngle(Pitch));
                    writer.Write(CommunicationBase.EncodeAngle(Roll));
                    break;
                case Coding.Motion:
                    writer.Write(CommunicationBase.EncodeMotion(Yaw));
                    writer.Write(CommunicationBase.EncodeMotion(Pitch));
                    writer.Write(CommunicationBase.EncodeMotion(Roll));
                    break;
                case Coding.General:
                    writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Yaw));
                    writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Pitch));
                    writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Roll));
                    break;
                default:
                    break;
            }
        }

        [OnSerializing]
        private void OnJsonSerializing(StreamingContext context)
        {
            Yaw = MathTools.Cyclic2PI(Yaw) * Constants.RadToDegRatio;
            Pitch = MathTools.Cyclic2PI(Pitch) * Constants.RadToDegRatio;
            Roll = MathTools.Cyclic2PI(Roll) * Constants.RadToDegRatio;
        }

        [OnSerialized]
        private void OnJsonSerialized(StreamingContext context)
        {
            ConvertToRadians();
        }

        [OnDeserialized]
        private void OnJsonDeserialized(StreamingContext context)
        {
            ConvertToRadians();
        }


        public override bool Equals(object obj)
        {
            if (obj is EulerAngles checkedObject)
            {
                return checkedObject.Yaw == this.Yaw && checkedObject.Pitch == this.Pitch && checkedObject.Roll == this.Roll;
            }
            else return false;
        }

        public override string ToString()
        {
            string result = "";
            result += String.Format("Yaw: {0:0.000}, ", Yaw * Constants.RadToDegRatio);
            result += String.Format("Pitch: {0:0.000}, ", Pitch * Constants.RadToDegRatio);
            result += String.Format("Roll: {0:0.000}", Roll * Constants.RadToDegRatio);
            return result;
        }

    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\EulerData.cs
// ---------------------------------------------------------

using Infrastructure.Serialization;

using System.IO;

namespace Infrastructure.Navigation.EulerCalculations
{
    public class EulerData
    {
        public EulerAngles Angles { get; set; }
        public EulerAngles Rates { get; set; }

        public EulerAngles Angles_Deg
        {
            get
            {
                EulerAngles output = new EulerAngles();
                output = Angles.Clone();
                output.ConvertToDegrees();
                return output;
            }

            set
            {
                value.ConvertToRadians();
                Angles = value.Clone();
            }
        }

        public EulerAngles Rates_Deg
        {
            get
            {
                EulerAngles output = new EulerAngles(); ;
                output = Rates.Clone();
                output.ConvertToDegrees();
                return output;
            }

            set
            {
                value.ConvertToRadians();
                Rates = value.Clone();
            }
        }

        public bool IsClear => (Angles.IsClear) && (Rates.IsClear);

        public void Clear()
        {
            Angles.Clear();
            Rates.Clear();
        }

        public EulerData Clone()
        {
            EulerData outValue = new EulerData();
            outValue.Angles = this.Angles.Clone();
            outValue.Rates = this.Rates.Clone();
            return outValue;
        }

        public int Length
        {
            get
            {
                return 6 * sizeof(double);
            }
        }

        public static int BinLength
        {
            get
            {
                return 2 * EulerAngles.BinLength;
            }
        }

        public EulerData()
        {
            Angles = new EulerAngles();
            Rates = new EulerAngles();
            Clear();
        }

        public EulerData(EulerAngles angles, EulerAngles rates)
        {
            Angles = angles.Clone();
            Rates = rates.Clone();
        }

        public void ConvertToRadians()
        {
            Angles.ConvertToRadians();
            Rates.ConvertToRadians();
        }

        public void ConvertToDegrees()
        {
            Angles.ConvertToDegrees();
            Rates.ConvertToDegrees();
        }

        /// <summary>
        /// Decode Constructor
        /// </summary>
        /// <param name="reader"></param>
        public EulerData(BinaryReader reader)
        {
            Angles = new EulerAngles(reader, Coding.Angle);
            Rates = new EulerAngles(reader, Coding.Motion);
        }

        public void Encode(BinaryWriter writer)
        {
            Angles.Encode(writer, Coding.Angle);
            Rates.Encode(writer, Coding.Motion);
        }
    }
}



// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\IntegratedInsOutputItem.cs
// ---------------------------------------------------------

using Infrastructure.FileManagement.DataRecording;
using Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

using System;
using System.Collections.Generic;

namespace RecordDecoderPro.ItemTemplates
{
    internal sealed class IntegratedInsOutputItem : RecordTypeItem
    {
        #region Properties

        public IntegratedInsOutputDictionary OutputDict { get; private set; }

        #endregion

        #region Columns

        public static readonly string[] IntegratedInsOutputColumns =
        {
            "RcvTime[hms]", "RcvTime[sec]",

            "OutputTimeDeviceCode", "OutputTimeDeviceId", "OutputTime[hms]", "OutputTime[sec]",

            "PositionLatDeviceCode", "PositionLatDeviceId", "PositionLatValue",
            "PositionLonDeviceCode", "PositionLonDeviceId", "PositionLonValue",
            "PositionAltDeviceCode", "PositionAltDeviceId", "PositionAltValue",

            "EulerRollDeviceCode", "EulerRollDeviceId", "EulerRollValue",
            "EulerPitchDeviceCode", "EulerPitchDeviceId", "EulerPitchValue",
            "EulerAzimuthDeviceCode", "EulerAzimuthDeviceId", "EulerAzimuthValue",

            "EulerRollRateDeviceCode", "EulerRollRateDeviceId", "EulerRollRateValue",
            "EulerPitchRateDeviceCode", "EulerPitchRateDeviceId", "EulerPitchRateValue",
            "EulerAzimuthRateDeviceCode", "EulerAzimuthRateDeviceId", "EulerAzimuthRateValue",

            "VelocityTotalDeviceCode", "VelocityTotalDeviceId", "VelocityTotalValue",
            "VelocityNorthDeviceCode", "VelocityNorthDeviceId", "VelocityNorthValue",
            "VelocityEastDeviceCode", "VelocityEastDeviceId", "VelocityEastValue",
            "VelocityDownDeviceCode", "VelocityDownDeviceId", "VelocityDownValue",

            "StatusDeviceCode", "StatusDeviceId", "StatusValue",
            "CourseDeviceCode", "CourseDeviceId", "CourseValue",
        };

        #endregion

        #region Constructors

        // Creates a new instance and initializes column names
        public IntegratedInsOutputItem() : base()
        {
            ColumnsNames = IntegratedInsOutputColumns;
        }

        #endregion

        #region Functions

        // Initializes item dictionary from raw binary payload
        public void InitializeDict(DataRecordHeader i_Header, byte[] i_RawData)
        {
            OutputDict = new IntegratedInsOutputDictionary(i_Header, i_RawData);
            dict = OutputDict.Dictionary;
        }

        #endregion

        #region Nested Types

        internal sealed class IntegratedInsOutputDictionary
        {
            #region Properties

            public Dictionary<string, string> Dictionary { get; }

            #endregion

            #region Constructors

            // Creates a new dictionary and processes raw data
            public IntegratedInsOutputDictionary(DataRecordHeader i_Header, byte[] i_RawData)
            {
                Dictionary = new Dictionary<string, string>();
                Process(i_Header, i_RawData);
            }

            #endregion

            #region Private Functions

            // Decodes integrated output using a CommFrame and formats values into CSV-ready columns
            private void Process(DataRecordHeader i_Header, byte[] i_RawData)
            {
                int i = 0;

                IntegratedInsOutput_CommFrame frame = new IntegratedInsOutput_CommFrame();
                frame.DecodeBinaryData(i_RawData, i_Header.DataLength);

                // RcvTime (from Header)
                DateTime rcvTime = DateTime.FromBinary(i_Header.Time);
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{rcvTime:HH:mm:ss.fff},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{rcvTime.TimeOfDay.TotalSeconds:F4},");

                // OutputTime (Triplet from Payload)
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTimeDeviceCode},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTimeDeviceId},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTime:HH:mm:ss.fff},");
                Dictionary.Add(IntegratedInsOutputColumns[i++], $"{frame.Data.OutputTime.TimeOfDay.TotalSeconds:F4},");

                // Position Triplets
                AddTriplet(ref i, frame.Data.PositionLat);
                AddTriplet(ref i, frame.Data.PositionLon);
                AddTriplet(ref i, frame.Data.PositionAlt);

                // Euler Angles Triplets
                AddTriplet(ref i, frame.Data.EulerRoll);
                AddTriplet(ref i, frame.Data.EulerPitch);
                AddTriplet(ref i, frame.Data.EulerAzimuth);

                // Euler Rates Triplets
                AddTriplet(ref i, frame.Data.EulerRollRate);
                AddTriplet(ref i, frame.Data.EulerPitchRate);
                AddTriplet(ref i, frame.Data.EulerAzimuthRate);

                // Velocity Triplets
                AddTriplet(ref i, frame.Data.VelocityTotalTriplet);
                AddTriplet(ref i, frame.Data.VelocityNorth);
                AddTriplet(ref i, frame.Data.VelocityEast);
                AddTriplet(ref i, frame.Data.VelocityDown);

                // Status and Course Triplets
                AddTriplet(ref i, frame.Data.StatusTriplet);
                AddTriplet(ref i, frame.Data.CourseTriplet);
            }

            // Adds DeviceCode + DeviceId + Value using the current column index
            private void AddTriplet(ref int io_Index, IntegratedValueTriplet i_Triplet)
            {
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.DeviceCode},");
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.DeviceId},");
                Dictionary.Add(IntegratedInsOutputColumns[io_Index++], $"{i_Triplet.Value:F8},");
            }

            #endregion
        }

        #endregion
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\IntegratedInsOutputStatusFlags.cs
// ---------------------------------------------------------

using System;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

// Unified status flags for IntegratedInsOutput_Data StatusValue bitmask
[Flags]
public enum IntegratedInsOutputStatusFlags : uint
{
    None = 0,

    // Time validation
    OutputTimeValid = 1u << 0,

    // Position validation
    PositionLatValid = 1u << 1,
    PositionLonValid = 1u << 2,
    PositionAltValid = 1u << 3,

    // Euler validation
    RollValid = 1u << 4,
    PitchValid = 1u << 5,
    AzimuthValid = 1u << 6,

    // Rate validation
    RollRateValid = 1u << 7,
    PitchRateValid = 1u << 8,
    AzimuthRateValid = 1u << 9,

    // Velocity validation
    VelocityTotalValid = 1u << 10,
    VelocityNorthValid = 1u << 11,
    VelocityEastValid = 1u << 12,
    VelocityDownValid = 1u << 13,

    // Course validation
    CourseValid = 1u << 14
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\IntegratedInsOutput_CommFrame.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.Infrastructure\LEGACY_TO_BE_DELETED\IntegratedInsOutput_CommFrame.cs
using Infrastructure.Enums;

using System.IO;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

// Builds/decodes the integrated INS output binary frame (sync + payload + checksum)
public sealed class IntegratedInsOutput_CommFrame
{
    #region Constants
    // Frame sync byte defined for the integrated output protocol
    private const byte m_Sync = 0x50;
    #endregion

    #region Private Fields
    private readonly object m_LockObject;
    private IntegratedInsOutput_Data m_Data;
    private byte m_Checksum;
    #endregion

    #region Properties
    // Returns the total binary length (Sync + Payload + Checksum)
    public static int BinLength { get; } = IntegratedInsOutput_Data.BinLength + 2 * sizeof(byte);

    // Returns a snapshot of the current data model
    public IntegratedInsOutput_Data Data
    {
        get { lock (m_LockObject) { return m_Data.Clone(); } }
    }
    #endregion

    #region Constructors
    // Creates a new integrated output comm frame instance
    public IntegratedInsOutput_CommFrame()
    {
        m_LockObject = new object();
        m_Data = new IntegratedInsOutput_Data();
        m_Checksum = 0;
    }
    #endregion

    #region Decode
    // Decodes a full frame from a raw byte array
    public BinaryDataDecodingStatus DecodeBinaryData(byte[] i_BinaryData, int i_DataSize)
    {
        if (i_BinaryData == null || i_DataSize < BinLength) { return BinaryDataDecodingStatus.LengthError; }

        using (MemoryStream m = new MemoryStream(i_BinaryData))
        using (BinaryReader reader = new BinaryReader(m))
        {
            return DecodeBinaryData(reader, i_BinaryData, i_DataSize);
        }
    }

    // Decodes a full frame from a binary reader and validates the protocol sync word
    public BinaryDataDecodingStatus DecodeBinaryData(BinaryReader i_Reader, byte[] i_SourceBuffer, int i_DataSize)
    {
        if (i_Reader == null || i_DataSize < BinLength) { return BinaryDataDecodingStatus.LengthError; }

        byte sync = i_Reader.ReadByte();
        if (sync != m_Sync) { return BinaryDataDecodingStatus.SyncError; }

        IntegratedInsOutput_Data tmpData = new IntegratedInsOutput_Data();
        tmpData.ReadBinary(i_Reader);

        byte checksum = i_Reader.ReadByte();

        // Validates checksum if a source buffer is provided for calculation
        if (i_SourceBuffer != null)
        {
            byte expected = CalculateChecksum(i_SourceBuffer, BinLength);
            // Validation can be enabled here for strict protocol enforcement
        }

        lock (m_LockObject)
        {
            m_Data = tmpData;
            m_Checksum = checksum;
        }

        return BinaryDataDecodingStatus.Success;
    }
    #endregion

    #region Encode
    // Encodes the current data snapshot into a binary frame with checksum
    public void EncodeBinaryData(ref byte[] io_OutArray, ref int io_Size)
    {
        if (io_OutArray == null || io_OutArray.Length < BinLength) { io_Size = 0; return; }

        using (MemoryStream m = new MemoryStream(io_OutArray))
        using (BinaryWriter writer = new BinaryWriter(m))
        {
            writer.Write(m_Sync);

            IntegratedInsOutput_Data snapshot = Data;
            snapshot.Encode(writer);

            writer.Write((byte)0); // Placeholder for checksum
        }

        byte checksum = CalculateChecksum(io_OutArray, BinLength);
        io_OutArray[BinLength - 1] = checksum;
        io_Size = BinLength;

        lock (m_LockObject)
        {
            m_Checksum = checksum;
        }
    }
    #endregion

    #region Private Helpers
    // Calculates a simple additive checksum over the frame (excluding sync and checksum bytes)
    private static byte CalculateChecksum(byte[] i_Buffer, int i_FrameLength)
    {
        byte checksum = 0;

        // Sum bytes [1..FrameLength-2] excluding the sync at 0 and the checksum position at the end
        for (int i = 1; i < i_FrameLength - 1; i++)
        {
            checksum += i_Buffer[i];
        }

        return checksum;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\IntegratedInsOutput_Data.cs
// ---------------------------------------------------------

using Infrastructure.DataStructures;
using Infrastructure.Navigation.EulerCalculations;

using System;
using System.IO;

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

public sealed class IntegratedInsOutput_Data
{
    #region Private Fields
    private DateTime m_OutputTime;
    private WGS84Data m_Position;
    private EulerData m_EulerData;
    private NEDData m_NedVelocity;
    private double m_Course;
    private uint m_StatusValue;
    private readonly object m_LockObject;
    #endregion

    #region Properties

    // Output time (selected source)
    public ushort OutputTimeDeviceCode { get; set; }
    public ushort OutputTimeDeviceId { get; set; }
    public DateTime OutputTime { get { lock (m_LockObject) { return m_OutputTime; } } set { lock (m_LockObject) { m_OutputTime = value; } } }

    // Position sources (per field)
    public ushort LatitudeDeviceCode { get; set; }
    public ushort LatitudeDeviceId { get; set; }
    public ushort LongitudeDeviceCode { get; set; }
    public ushort LongitudeDeviceId { get; set; }
    public ushort AltitudeDeviceCode { get; set; }
    public ushort AltitudeDeviceId { get; set; }

    // Euler angles sources (per field)
    public ushort RollDeviceCode { get; set; }
    public ushort RollDeviceId { get; set; }
    public ushort PitchDeviceCode { get; set; }
    public ushort PitchDeviceId { get; set; }
    public ushort AzimuthDeviceCode { get; set; }
    public ushort AzimuthDeviceId { get; set; }

    // Euler rates sources (per field)
    public ushort RollRateDeviceCode { get; set; }
    public ushort RollRateDeviceId { get; set; }
    public ushort PitchRateDeviceCode { get; set; }
    public ushort PitchRateDeviceId { get; set; }
    public ushort AzimuthRateDeviceCode { get; set; }
    public ushort AzimuthRateDeviceId { get; set; }

    // Velocity sources (per field)
    public ushort VelocityTotalDeviceCode { get; set; }
    public ushort VelocityTotalDeviceId { get; set; }
    public ushort VelocityNorthDeviceCode { get; set; }
    public ushort VelocityNorthDeviceId { get; set; }
    public ushort VelocityEastDeviceCode { get; set; }
    public ushort VelocityEastDeviceId { get; set; }
    public ushort VelocityDownDeviceCode { get; set; }
    public ushort VelocityDownDeviceId { get; set; }

    // Status sources (single value)
    public ushort StatusDeviceCode { get; set; }
    public ushort StatusDeviceId { get; set; }
    public uint StatusValue { get { lock (m_LockObject) { return m_StatusValue; } } set { lock (m_LockObject) { m_StatusValue = value; } } }

    // Course sources (single value)
    public ushort CourseDeviceCode { get; set; }
    public ushort CourseDeviceId { get; set; }

    // Position (values)
    public WGS84Data Position { get { lock (m_LockObject) { return m_Position.Clone(); } } set { lock (m_LockObject) { m_Position = value.Clone(); } } }
    public WGS84Data Position_Deg { get { lock (m_LockObject) { var p = m_Position.Clone(); p.ConvertToDegrees(); return p; } } }

    // Euler (values)
    public EulerData EulerData { get { lock (m_LockObject) { return m_EulerData.Clone(); } } set { lock (m_LockObject) { m_EulerData = value.Clone(); } } }
    public EulerData EulerData_Deg { get { lock (m_LockObject) { var e = m_EulerData.Clone(); e.ConvertToDegrees(); return e; } } }

    // Velocity (values)
    public NEDData VelocityVector { get { lock (m_LockObject) { return m_NedVelocity.Clone(); } } set { lock (m_LockObject) { m_NedVelocity = value.Clone(); } } }
    public double VelocityTotal { get { lock (m_LockObject) { return Math.Sqrt(m_NedVelocity.Down * m_NedVelocity.Down + m_NedVelocity.East * m_NedVelocity.East + m_NedVelocity.North * m_NedVelocity.North); } } }

    // Course (value)
    public double Course { get { lock (m_LockObject) { return m_Course; } } set { lock (m_LockObject) { m_Course = value; } } }

    // Binary payload length for CommFrame Encode/Decode
    public static int BinLength
    {
        get
        {
            // OutputTime: DeviceCode(ushort) + DeviceId(ushort) + DateTimeBinary(long)
            // 14 numeric fields: each DeviceCode(ushort) + DeviceId(ushort) + Value(double)
            // Status: DeviceCode(ushort) + DeviceId(ushort) + Value(uint)
            return (2 * sizeof(ushort) + sizeof(long)) + (14 * (2 * sizeof(ushort) + sizeof(double))) + (2 * sizeof(ushort) + sizeof(uint));
        }
    }

    #endregion

    #region Triplet Properties (for Decoder Compatibility)

    public IntegratedValueTriplet PositionLat => new(LatitudeDeviceCode, LatitudeDeviceId, Position.Lat);
    public IntegratedValueTriplet PositionLon => new(LongitudeDeviceCode, LongitudeDeviceId, Position.Lon);
    public IntegratedValueTriplet PositionAlt => new(AltitudeDeviceCode, AltitudeDeviceId, Position.Alt);

    public IntegratedValueTriplet EulerRoll => new(RollDeviceCode, RollDeviceId, EulerData.Angles.Roll);
    public IntegratedValueTriplet EulerPitch => new(PitchDeviceCode, PitchDeviceId, EulerData.Angles.Pitch);
    public IntegratedValueTriplet EulerAzimuth => new(AzimuthDeviceCode, AzimuthDeviceId, EulerData.Angles.Yaw);

    public IntegratedValueTriplet EulerRollRate => new(RollRateDeviceCode, RollRateDeviceId, EulerData.Rates.Roll);
    public IntegratedValueTriplet EulerPitchRate => new(PitchRateDeviceCode, PitchRateDeviceId, EulerData.Rates.Pitch);
    public IntegratedValueTriplet EulerAzimuthRate => new(AzimuthRateDeviceCode, AzimuthRateDeviceId, EulerData.Rates.Yaw);

    public IntegratedValueTriplet VelocityTotalTriplet => new(VelocityTotalDeviceCode, VelocityTotalDeviceId, VelocityTotal);
    public IntegratedValueTriplet VelocityNorth => new(VelocityNorthDeviceCode, VelocityNorthDeviceId, VelocityVector.North);
    public IntegratedValueTriplet VelocityEast => new(VelocityEastDeviceCode, VelocityEastDeviceId, VelocityVector.East);
    public IntegratedValueTriplet VelocityDown => new(VelocityDownDeviceCode, VelocityDownDeviceId, VelocityVector.Down);

    public IntegratedValueTriplet StatusTriplet => new(StatusDeviceCode, StatusDeviceId, StatusValue);
    public IntegratedValueTriplet CourseTriplet => new(CourseDeviceCode, CourseDeviceId, Course);

    #endregion

    #region Constructors

    // Creates a new integrated output data instance
    public IntegratedInsOutput_Data()
    {
        m_LockObject = new object();
        m_Position = new WGS84Data();
        m_EulerData = new EulerData();
        m_NedVelocity = new NEDData();
        Clear();
    }

    #endregion

    #region Functions

    // Resets values and sources to defaults
    public void Clear()
    {
        lock (m_LockObject)
        {
            OutputTimeDeviceCode = 0; OutputTimeDeviceId = 0; m_OutputTime = DateTime.UtcNow;

            LatitudeDeviceCode = 0; LatitudeDeviceId = 0;
            LongitudeDeviceCode = 0; LongitudeDeviceId = 0;
            AltitudeDeviceCode = 0; AltitudeDeviceId = 0;

            RollDeviceCode = 0; RollDeviceId = 0;
            PitchDeviceCode = 0; PitchDeviceId = 0;
            AzimuthDeviceCode = 0; AzimuthDeviceId = 0;

            RollRateDeviceCode = 0; RollRateDeviceId = 0;
            PitchRateDeviceCode = 0; PitchRateDeviceId = 0;
            AzimuthRateDeviceCode = 0; AzimuthRateDeviceId = 0;

            VelocityTotalDeviceCode = 0; VelocityTotalDeviceId = 0;
            VelocityNorthDeviceCode = 0; VelocityNorthDeviceId = 0;
            VelocityEastDeviceCode = 0; VelocityEastDeviceId = 0;
            VelocityDownDeviceCode = 0; VelocityDownDeviceId = 0;

            StatusDeviceCode = 0; StatusDeviceId = 0; m_StatusValue = 0;

            CourseDeviceCode = 0; CourseDeviceId = 0; m_Course = 0;

            m_Position.Clear();
            m_EulerData.Clear();
            m_NedVelocity.Clear();
        }
    }

    // Creates a deep copy of the instance
    public IntegratedInsOutput_Data Clone()
    {
        var outValue = new IntegratedInsOutput_Data();
        lock (m_LockObject)
        {
            outValue.OutputTimeDeviceCode = OutputTimeDeviceCode;
            outValue.OutputTimeDeviceId = OutputTimeDeviceId;
            outValue.m_OutputTime = m_OutputTime;

            outValue.LatitudeDeviceCode = LatitudeDeviceCode; outValue.LatitudeDeviceId = LatitudeDeviceId;
            outValue.LongitudeDeviceCode = LongitudeDeviceCode; outValue.LongitudeDeviceId = LongitudeDeviceId;
            outValue.AltitudeDeviceCode = AltitudeDeviceCode; outValue.AltitudeDeviceId = AltitudeDeviceId;

            outValue.RollDeviceCode = RollDeviceCode; outValue.RollDeviceId = RollDeviceId;
            outValue.PitchDeviceCode = PitchDeviceCode; outValue.PitchDeviceId = PitchDeviceId;
            outValue.AzimuthDeviceCode = AzimuthDeviceCode; outValue.AzimuthDeviceId = AzimuthDeviceId;

            outValue.RollRateDeviceCode = RollRateDeviceCode; outValue.RollRateDeviceId = RollRateDeviceId;
            outValue.PitchRateDeviceCode = PitchRateDeviceCode; outValue.PitchRateDeviceId = PitchRateDeviceId;
            outValue.AzimuthRateDeviceCode = AzimuthRateDeviceCode; outValue.AzimuthRateDeviceId = AzimuthRateDeviceId;

            outValue.VelocityTotalDeviceCode = VelocityTotalDeviceCode; outValue.VelocityTotalDeviceId = VelocityTotalDeviceId;
            outValue.VelocityNorthDeviceCode = VelocityNorthDeviceCode; outValue.VelocityNorthDeviceId = VelocityNorthDeviceId;
            outValue.VelocityEastDeviceCode = VelocityEastDeviceCode; outValue.VelocityEastDeviceId = VelocityEastDeviceId;
            outValue.VelocityDownDeviceCode = VelocityDownDeviceCode; outValue.VelocityDownDeviceId = VelocityDownDeviceId;

            outValue.StatusDeviceCode = StatusDeviceCode; outValue.StatusDeviceId = StatusDeviceId; outValue.m_StatusValue = m_StatusValue;

            outValue.CourseDeviceCode = CourseDeviceCode; outValue.CourseDeviceId = CourseDeviceId; outValue.m_Course = m_Course;

            outValue.m_Position = m_Position.Clone();
            outValue.m_EulerData = m_EulerData.Clone();
            outValue.m_NedVelocity = m_NedVelocity.Clone();
        }
        return outValue;
    }

    // Reads the binary payload in the locked field order
    public void ReadBinary(BinaryReader i_Reader)
    {
        lock (m_LockObject)
        {
            OutputTimeDeviceCode = i_Reader.ReadUInt16();
            OutputTimeDeviceId = i_Reader.ReadUInt16();
            m_OutputTime = DateTime.FromBinary(i_Reader.ReadInt64());

            LatitudeDeviceCode = i_Reader.ReadUInt16();
            LatitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Lat = i_Reader.ReadDouble();

            LongitudeDeviceCode = i_Reader.ReadUInt16();
            LongitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Lon = i_Reader.ReadDouble();

            AltitudeDeviceCode = i_Reader.ReadUInt16();
            AltitudeDeviceId = i_Reader.ReadUInt16();
            m_Position.Alt = i_Reader.ReadDouble();

            RollDeviceCode = i_Reader.ReadUInt16();
            RollDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Roll = i_Reader.ReadDouble();

            PitchDeviceCode = i_Reader.ReadUInt16();
            PitchDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Pitch = i_Reader.ReadDouble();

            AzimuthDeviceCode = i_Reader.ReadUInt16();
            AzimuthDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Angles.Yaw = i_Reader.ReadDouble();

            RollRateDeviceCode = i_Reader.ReadUInt16();
            RollRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Roll = i_Reader.ReadDouble();

            PitchRateDeviceCode = i_Reader.ReadUInt16();
            PitchRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Pitch = i_Reader.ReadDouble();

            AzimuthRateDeviceCode = i_Reader.ReadUInt16();
            AzimuthRateDeviceId = i_Reader.ReadUInt16();
            m_EulerData.Rates.Yaw = i_Reader.ReadDouble();

            VelocityTotalDeviceCode = i_Reader.ReadUInt16();
            VelocityTotalDeviceId = i_Reader.ReadUInt16();
            var velocityTotal = i_Reader.ReadDouble(); // Stored as a field even if derivable

            VelocityNorthDeviceCode = i_Reader.ReadUInt16();
            VelocityNorthDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.North = i_Reader.ReadDouble();

            VelocityEastDeviceCode = i_Reader.ReadUInt16();
            VelocityEastDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.East = i_Reader.ReadDouble();

            VelocityDownDeviceCode = i_Reader.ReadUInt16();
            VelocityDownDeviceId = i_Reader.ReadUInt16();
            m_NedVelocity.Down = i_Reader.ReadDouble();

            StatusDeviceCode = i_Reader.ReadUInt16();
            StatusDeviceId = i_Reader.ReadUInt16();
            m_StatusValue = i_Reader.ReadUInt32();

            CourseDeviceCode = i_Reader.ReadUInt16();
            CourseDeviceId = i_Reader.ReadUInt16();
            m_Course = i_Reader.ReadDouble();

            // Keep the stored total as-is if you later want to expose it directly
            _ = velocityTotal;
        }
    }

    // Encodes the binary payload in the locked field order
    public void Encode(BinaryWriter i_Writer)
    {
        lock (m_LockObject)
        {
            i_Writer.Write(OutputTimeDeviceCode);
            i_Writer.Write(OutputTimeDeviceId);
            i_Writer.Write(m_OutputTime.ToBinary());

            i_Writer.Write(LatitudeDeviceCode);
            i_Writer.Write(LatitudeDeviceId);
            i_Writer.Write(m_Position.Lat);

            i_Writer.Write(LongitudeDeviceCode);
            i_Writer.Write(LongitudeDeviceId);
            i_Writer.Write(m_Position.Lon);

            i_Writer.Write(AltitudeDeviceCode);
            i_Writer.Write(AltitudeDeviceId);
            i_Writer.Write(m_Position.Alt);

            i_Writer.Write(RollDeviceCode);
            i_Writer.Write(RollDeviceId);
            i_Writer.Write(m_EulerData.Angles.Roll);

            i_Writer.Write(PitchDeviceCode);
            i_Writer.Write(PitchDeviceId);
            i_Writer.Write(m_EulerData.Angles.Pitch);

            i_Writer.Write(AzimuthDeviceCode);
            i_Writer.Write(AzimuthDeviceId);
            i_Writer.Write(m_EulerData.Angles.Yaw);

            i_Writer.Write(RollRateDeviceCode);
            i_Writer.Write(RollRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Roll);

            i_Writer.Write(PitchRateDeviceCode);
            i_Writer.Write(PitchRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Pitch);

            i_Writer.Write(AzimuthRateDeviceCode);
            i_Writer.Write(AzimuthRateDeviceId);
            i_Writer.Write(m_EulerData.Rates.Yaw);

            i_Writer.Write(VelocityTotalDeviceCode);
            i_Writer.Write(VelocityTotalDeviceId);
            i_Writer.Write(VelocityTotal); // Stored total

            i_Writer.Write(VelocityNorthDeviceCode);
            i_Writer.Write(VelocityNorthDeviceId);
            i_Writer.Write(m_NedVelocity.North);

            i_Writer.Write(VelocityEastDeviceCode);
            i_Writer.Write(VelocityEastDeviceId);
            i_Writer.Write(m_NedVelocity.East);

            i_Writer.Write(VelocityDownDeviceCode);
            i_Writer.Write(VelocityDownDeviceId);
            i_Writer.Write(m_NedVelocity.Down);

            i_Writer.Write(StatusDeviceCode);
            i_Writer.Write(StatusDeviceId);
            i_Writer.Write(m_StatusValue);

            i_Writer.Write(CourseDeviceCode);
            i_Writer.Write(CourseDeviceId);
            i_Writer.Write(m_Course);
        }
    }

    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\IntegratedValueTriplet.cs
// ---------------------------------------------------------

namespace Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput
{
    public struct IntegratedValueTriplet
    {
        public ushort DeviceCode { get; }
        public ushort DeviceId { get; }
        public double Value { get; }

        public IntegratedValueTriplet(ushort i_DeviceCode, ushort i_DeviceId, double i_Value)
        {
            DeviceCode = i_DeviceCode;
            DeviceId = i_DeviceId;
            Value = i_Value;
        }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\Log4Net.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Logging;

using System;

namespace log4net
{
    public interface ILog
    {
        void Info(string message);
        void Error(string message);
        void Error(string message, Exception ex);
    }

    public class Log4NetAdapter : ILog
    {
        private readonly ILogService m_Target;
        private readonly string m_Source;

        public Log4NetAdapter(ILogService target, string source)
        {
            m_Target = target;
            m_Source = source;
        }

        public void Info(string message) => m_Target.Info(m_Source, message);
        public void Error(string message) => m_Target.Error(m_Source, message);
        public void Error(string message, Exception ex) => m_Target.Error(m_Source, message, ex);
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\NEDData.cs
// ---------------------------------------------------------

using Infrastructure.Serialization;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Infrastructure.Navigation
{
    public class NEDData
    {
        public double North { get; set; }
        public double East { get; set; }
        public double Down { get; set; }

        public int Length
        {
            get
            {
                return 3 * sizeof(double);
            }
        }

        public static int BinLength
        {
            get
            {
                return 3 * sizeof(Int32);
            }
        }

        public NEDData(BinaryReader reader)
        {
            North = CommunicationBase.DecodeGeneralDoubleValue(reader);
            East = CommunicationBase.DecodeGeneralDoubleValue(reader);
            Down = CommunicationBase.DecodeGeneralDoubleValue(reader);
        }

        public NEDData()
        {
            Clear();
        }

        public void Clear()
        {
            North = 0;
            East = 0;
            Down = 0;
        }

        public void Encode(BinaryWriter writer)
        {
            writer.Write(CommunicationBase.EncodeGeneralDoubleValue(North));
            writer.Write(CommunicationBase.EncodeGeneralDoubleValue(East));
            writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Down));
        }


        public NEDData Clone()
        {
            return (NEDData)MemberwiseClone();
        }


        public override bool Equals(object obj)
        {
            if (obj is NEDData checkedObject)
            {
                return checkedObject.North == this.North &&
                       checkedObject.East == this.East &&
                       checkedObject.Down == this.Down;
            }
            else return false;
        }

        public override string ToString()
        {
            string result = "";
            result += String.Format("North: {0:0.000}, ", North);
            result += String.Format("East: {0:0.000}, ", East);
            result += String.Format("Down: {0:0.000}", Down);
            return result;
        }
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\RecordingSettings.cs
// ---------------------------------------------------------

using System.Collections.Generic;

namespace Infrastructure.FileManagement.Settings
{
    public class RecordingSettings
    {
        public List<string> ScenariosList { get; set; } = new List<string>();
        public ulong MaximumFileSize { get; set; } = 1024 * 1024 * 10; // 10MB default

        public void LoadDefaultSettings()
        {
            ScenariosList = new List<string> { "DefaultScenario" };
            MaximumFileSize = 1024 * 1024 * 10;
        }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\RecordStatistics.cs
// ---------------------------------------------------------

using System;

namespace Infrastructure.FileManagement.DataRecording
{
    public class RecordStatistics
    {
        public DateTime StartTime { get; set; }
        public TimeSpan Elapsed { get; set; }
        public long FileSizeBytes { get; set; }
        public long RecordingDiskTotalSize { get; set; }
        public long RecordingDiskFreeSpace { get; set; }

        public RecordStatistics Clone()
        {
            return (RecordStatistics)this.MemberwiseClone();
        }
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\RecordTypeItem.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Infrastructure.Recording;

using System.Collections.Generic;
namespace RecordDecoderPro.ItemTemplates
{
    public class RecordTypeItem : ViewModelBase
    {

        public string recordTypeName { get; set; }
        public List<RecordIDItem> recordIDs { get; set; }
        public bool isChecked { get; set; }
        public List<RecordFieldItem> recordFields { get; set; }
        public Dictionary<string, string> dict { get; set; }

        public RecordTypeItem()
        {
            recordIDs = new List<RecordIDItem>();
            recordFields = new List<RecordFieldItem>();
            isChecked = true;
        }

        private string[] columnsNames { get; set; }
        public string[] ColumnsNames
        {
            get { return columnsNames; }
            set
            {
                columnsNames = value;
                foreach (string name in columnsNames)
                {
                    recordFields.Add(new RecordFieldItem() { recordFieldName = name });
                }
            }
        }

        public RecordTypeItem Clone()
        {
            return (RecordTypeItem)MemberwiseClone();
        }
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\Singleton.cs
// ---------------------------------------------------------

namespace Infrastructure.Templates;

// Shim for VIC global singleton pattern
public static class Singleton<T> where T : new()
{
    private static T m_Instance = new T();
    public static T Instance => m_Instance;
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\VicCompatibilitySerialization.cs
// ---------------------------------------------------------

using System;
using System.IO;

namespace Infrastructure.Serialization;

public enum Coding
{
    Angle,
    Motion,
    General
}

public static class CommunicationBase
{
    // Mimics VIC binary encoding/decoding for doubles (simple pass-through for NIS testing)
    public static double DecodeAngle(BinaryReader i_Reader) => i_Reader.ReadDouble();
    public static double DecodeMotion(BinaryReader i_Reader) => i_Reader.ReadDouble();
    public static double DecodeGeneralDoubleValue(BinaryReader i_Reader) => i_Reader.ReadDouble();

    public static double EncodeAngle(double i_Value) => i_Value;
    public static double EncodeMotion(double i_Value) => i_Value;
    public static double EncodeGeneralDoubleValue(double i_Value) => i_Value;
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\VicCompatibilityTools.cs
// ---------------------------------------------------------

using System;

namespace Infrastructure.Tools;

public static class Constants
{
    public const double DegToRadRatio = Math.PI / 180.0;
    public const double RadToDegRatio = 180.0 / Math.PI;
}

public static class MathTools
{
    // Normalizes angle to [0, 2PI)
    public static double Cyclic2PI(double i_Angle)
    {
        double val = i_Angle % (2.0 * Math.PI);
        if (val < 0) val += (2.0 * Math.PI);
        return val;
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.Infrastructure\TO_BE_DELETED\WGS84Data.cs
// ---------------------------------------------------------

using Infrastructure.Serialization;
using Infrastructure.Tools;

using Microsoft.VisualBasic;

using System;
using System.IO;

using Constants = Infrastructure.Tools.Constants;

namespace Infrastructure.DataStructures;

public class WGS84Data
{
    #region Properties
    public double Lat { get; set; }
    public double Lon { get; set; }
    public double Alt { get; set; }
    #endregion

    #region Constructors
    // Default constructor
    public WGS84Data() { Clear(); }

    // Decode constructor matching VIC patterns
    public WGS84Data(BinaryReader i_Reader)
    {
        Lat = CommunicationBase.DecodeGeneralDoubleValue(i_Reader);
        Lon = CommunicationBase.DecodeGeneralDoubleValue(i_Reader);
        Alt = CommunicationBase.DecodeGeneralDoubleValue(i_Reader);
    }
    #endregion

    #region Functions
    // Resets values to zero
    public void Clear()
    {
        Lat = Lon = Alt = 0.0;
    }

    // Creates a deep copy
    public WGS84Data Clone()
    {
        return (WGS84Data)this.MemberwiseClone();
    }

    // Converts radians to degrees
    public void ConvertToDegrees()
    {
        Lat *= Constants.RadToDegRatio;
        Lon *= Constants.RadToDegRatio;
    }

    // Converts degrees to radians
    public void ConvertToRadians()
    {
        Lat *= Constants.DegToRadRatio;
        Lon *= Constants.DegToRadRatio;
    }

    // Binary encoding matching VIC patterns
    public void Encode(BinaryWriter i_Writer)
    {
        i_Writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Lat));
        i_Writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Lon));
        i_Writer.Write(CommunicationBase.EncodeGeneralDoubleValue(Alt));
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\app.manifest
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="NavigationIntegrationSystem.app"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- The ID below informs the system that this application is compatible with OS features first introduced in Windows 10. 
      It is necessary to support features in unpackaged applications, for example the custom titlebar implementation.
      For more info see https://docs.microsoft.com/windows/apps/windows-app-sdk/use-windows-app-sdk-run-time#declare-os-compatibility-in-your-application-manifest -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
  
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\App.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<Application x:Class="NavigationIntegrationSystem.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:converters="using:NavigationIntegrationSystem.UI.Converters" xmlns:local="using:NavigationIntegrationSystem">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
                <!--  Other merged dictionaries here  -->
            </ResourceDictionary.MergedDictionaries>

            <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter" />
            <converters:InverseBoolToVisibilityConverter x:Key="InverseBoolToVisibilityConverter" />
            <converters:BoolToConnectTextConverter x:Key="BoolToConnectTextConverter" />
            <converters:ConnectionKindToVisibilityConverter x:Key="ConnectionKindToVisibilityConverter" />
            <converters:DeviceStatusToBrushConverter x:Key="DeviceStatusToBrushConverter" />
            <converters:LogLevelToBrushConverter x:Key="LogLevelToBrushConverter" />
            <converters:StringNullOrEmptyToVisibilityConverter x:Key="StringNullOrEmptyToVisibilityConverter" />
            <converters:RecordingStatusToTextConverter x:Key="RecordingStatusToTextConverter" />
            <converters:RecordingStatusToIconConverter x:Key="RecordingStatusToIconConverter" />

            <converters:DevicesPaneModeToVisibilityConverter x:Key="PaneModeToSettingsVisibilityConverter" TargetMode="Settings" />
            <converters:DevicesPaneModeToVisibilityConverter x:Key="PaneModeToInspectVisibilityConverter" TargetMode="Inspect" />
        </ResourceDictionary>
    </Application.Resources>
</Application>


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\App.xaml.cs
// ---------------------------------------------------------

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Xaml;

using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Devices.Runtime;
using NavigationIntegrationSystem.Infrastructure.Logging;
using NavigationIntegrationSystem.UI.Bootstrap;
using NavigationIntegrationSystem.UI.Services.Logging;
using NavigationIntegrationSystem.UI.Services.Recording;

using System;

namespace NavigationIntegrationSystem;

// Boots the application, builds DI host, and opens the main window
public partial class App : Application
{
    #region Private Fields
    private readonly IHost m_Host;
    private Window? m_MainWindow;
    #endregion

    #region Properties
    public IServiceProvider Services => m_Host.Services;
    #endregion

    #region Ctors
    public App()
    {
        InitializeComponent();
        m_Host = HostBuilderFactory.Build();
    }
    #endregion

    #region Overrides
    protected override void OnLaunched(LaunchActivatedEventArgs args)
    {
        // 1. Warm up the UI Log Buffer
        var uiLogBuffer = Services.GetRequiredService<UiLogBuffer>();
        uiLogBuffer.AttachUiDispatcher(DispatcherQueue.GetForCurrentThread());

        var log = Services.GetRequiredService<ILogService>();
        log.Info(nameof(App), "NIS starting");

        // 2. Initialize device modules
        _ = Services.GetRequiredService<DevicesModuleBootstrapper>();
        
        // 3. Warm up the Recording Snapshot Service
        _ = Services.GetRequiredService<IntegrationSnapshotService>();

        // 4. Show MainWindow
        m_MainWindow = Services.GetRequiredService<MainWindow>();
        m_MainWindow.Activate();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\MainWindow.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<Window x:Class="NavigationIntegrationSystem.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:controls="using:NavigationIntegrationSystem.UI.Views.Controls" xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:local="using:NavigationIntegrationSystem" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" Title="NavigationIntegrationSystem" mc:Ignorable="d">

    <Window.SystemBackdrop>
        <MicaBackdrop />
    </Window.SystemBackdrop>

    <Grid x:Name="RootGrid">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <!--  Custom Title Bar  -->
        <controls:ShellHeaderControl x:Name="ShellHeader" Grid.Row="0" />

        <!--  Hamburger Menu  -->
        <NavigationView x:Name="Nav" Grid.Row="1" CompactPaneLength="48" IsBackButtonVisible="Collapsed" IsPaneOpen="True"
                        IsSettingsVisible="False" OpenPaneLength="200" PaneDisplayMode="Left" SelectionChanged="OnNavSelectionChanged">

            <!--  Main Items  -->
            <NavigationView.MenuItems>

                <!--  Integration  -->
                <NavigationViewItem Content="Integration" Tag="integration">
                    <NavigationViewItem.Icon>
                        <ImageIcon Source="ms-appx:///Assets/Icons/Home.svg" />
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <!--  Devices  -->
                <NavigationViewItem Content="Devices" Tag="devices">
                    <NavigationViewItem.Icon>
                        <ImageIcon Source="ms-appx:///Assets/Icons/Devices.svg" />
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <!--  Logs  -->
                <NavigationViewItem Content="Logs" Tag="logs">
                    <NavigationViewItem.Icon>
                        <ImageIcon Source="ms-appx:///Assets/Icons/Logs.svg" />
                    </NavigationViewItem.Icon>
                </NavigationViewItem>
            </NavigationView.MenuItems>

            <!--  Footer  -->
            <NavigationView.FooterMenuItems>
                <!--  Help  -->
                <NavigationViewItem Content="Help" Tag="help">
                    <NavigationViewItem.Icon>
                        <ImageIcon Source="ms-appx:///Assets/Icons/Help.svg" />
                    </NavigationViewItem.Icon>
                </NavigationViewItem>

                <!--  Settings  -->
                <NavigationViewItem Content="Settings" Tag="settings">
                    <NavigationViewItem.Icon>
                        <ImageIcon Source="ms-appx:///Assets/Icons/Settings.svg" />
                    </NavigationViewItem.Icon>
                </NavigationViewItem>
            </NavigationView.FooterMenuItems>

            <Frame x:Name="ContentFrame" />
        </NavigationView>
    </Grid>
</Window>


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\MainWindow.xaml.cs
// ---------------------------------------------------------

using Microsoft.UI;
using Microsoft.UI.Windowing;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;

using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.UI.Navigation;
using NavigationIntegrationSystem.UI.Services.UI.Navigation;
using NavigationIntegrationSystem.UI.ViewModels;

using System;

using Windows.Graphics;

using WinRT.Interop;

namespace NavigationIntegrationSystem;

// Hosts the main navigation shell and routes between pages
public sealed partial class MainWindow : Window
{
    #region Properties
    public MainViewModel ViewModel { get; }
    #endregion

    #region Private Fields
    private readonly NavigationService m_NavigationService;
    private readonly ILogService m_LogService;
    private const int c_DefaultWindowWidth = 1300;
    private const int c_DefaultWindowHeight = 820;
    #endregion

    #region Ctors
    public MainWindow(MainViewModel i_ViewModel, NavigationService i_NavigationService, ILogService i_LogService)
    {
        InitializeComponent();

        ViewModel = i_ViewModel;
        RootGrid.DataContext = i_ViewModel;
        m_LogService = i_LogService;
        m_NavigationService = i_NavigationService;

        InitializeTitleBar();
        InitWindowLayout();
        InitLogging();
        InitNavigation();
    }
    #endregion

    #region Private Functions
    // Enables custom title bar using the exposed element from our header control
    private void InitializeTitleBar()
    {
        ExtendsContentIntoTitleBar = true;

        // Access the public property we just created
        if (ShellHeader != null)
        {
            SetTitleBar(ShellHeader.TitleBarElement);
        }
    }

    // Initializes the window size and centers it on screen
    private void InitWindowLayout()
    {
        AppWindow appWindow = GetAppWindow();
        appWindow.Resize(new SizeInt32(c_DefaultWindowWidth, c_DefaultWindowHeight));
        CenterWindow(appWindow);
    }

    // Initializes the window logging behavior
    private void InitLogging()
    {
        m_LogService.Info(nameof(MainWindow), "MainWindow created");
    }

    // Initializes the navigation shell and routes to the default page
    private void InitNavigation()
    {
        string initialPage = NavKeys.Integration;

        m_NavigationService.Attach(ContentFrame);
        m_NavigationService.Navigate(initialPage);

        SelectNavigationItemByTag(initialPage);
    }

    // Selects a NavigationView item by its Tag value
    private void SelectNavigationItemByTag(string i_Tag)
    {
        foreach (var item in Nav.MenuItems)
        {
            if (item is NavigationViewItem navItem && navItem.Tag as string == i_Tag)
            {
                Nav.SelectedItem = navItem;
                break;
            }
        }
    }

    // Gets the current window AppWindow
    private AppWindow GetAppWindow()
    {
        IntPtr hwnd = WindowNative.GetWindowHandle(this);
        WindowId windowId = Win32Interop.GetWindowIdFromWindow(hwnd);
        return AppWindow.GetFromWindowId(windowId);
    }

    // Centers the window on the current display
    private void CenterWindow(AppWindow i_AppWindow)
    {
        DisplayArea displayArea = DisplayArea.GetFromWindowId(i_AppWindow.Id, DisplayAreaFallback.Primary);
        RectInt32 workArea = displayArea.WorkArea;

        int x = workArea.X + (workArea.Width - i_AppWindow.Size.Width) / 2;
        int y = workArea.Y + (workArea.Height - i_AppWindow.Size.Height) / 2;

        i_AppWindow.Move(new PointInt32(x, y));
    }
    #endregion

    #region Event Handlers
    // Navigates based on the selected menu item
    private void OnNavSelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
    { 
        if (args.SelectedItemContainer?.Tag is string tag) { m_NavigationService.Navigate(tag); } 
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\NavigationIntegrationSystem.UI.csproj
// ---------------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows10.0.19041.0</TargetFramework>
    <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
    <RootNamespace>NavigationIntegrationSystem.UI</RootNamespace>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <Platforms>x86;x64;ARM64</Platforms>
    <RuntimeIdentifiers>win-x86;win-x64;win-arm64</RuntimeIdentifiers>
    <UseWinUI>true</UseWinUI>
    <WinUISDKReferences>false</WinUISDKReferences>
    <EnableMsixTooling>true</EnableMsixTooling>
    <Nullable>enable</Nullable>
	<ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>true</ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch>
	<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Content Remove="Assets\Original\NIS Logo.png" />
  </ItemGroup>
  <ItemGroup>
    <None Remove="appsettings.json" />
    <None Remove="Assets\Icons\Devices.svg" />
    <None Remove="Assets\Icons\Help.svg" />
    <None Remove="Assets\Icons\Home.svg" />
    <None Remove="Assets\Icons\Logs.svg" />
    <None Remove="Assets\Icons\Settings.svg" />
    <None Remove="Views\Controls\ShellHeaderControl.xaml" />
    <None Remove="Views\Pages\DevicesPage.xaml" />
    <None Remove="Views\Pages\LogsPage.xaml" />
    <None Remove="Views\Pages\SettingsPage.xaml" />
    <None Remove="Views\Panes\DeviceInspectPaneView.xaml" />
    <None Remove="Views\Panes\DeviceSettingsPaneView.xaml" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Assets\SplashScreen.scale-200.png" />
    <Content Include="Assets\LockScreenLogo.scale-200.png" />
    <Content Include="Assets\Square150x150Logo.scale-200.png" />
    <Content Include="Assets\Square44x44Logo.scale-200.png" />
    <Content Include="Assets\Square44x44Logo.targetsize-24_altform-unplated.png" />
    <Content Include="Assets\Wide310x150Logo.scale-200.png" />
  </ItemGroup>

  <ItemGroup>
    <Manifest Include="$(ApplicationManifest)" />
  </ItemGroup>

  <!--
    Defining the "Msix" ProjectCapability here allows the Single-project MSIX Packaging
    Tools extension to be activated for this project even if the Windows App SDK Nuget
    package has not yet been restored.
  -->
  <ItemGroup Condition="'$(DisableMsixProjectCapabilityAddedByProject)'!='true' and '$(EnableMsixTooling)'=='true'">
    <ProjectCapability Include="Msix" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    <PackageReference Include="CommunityToolkit.WinUI.Collections" Version="8.2.251219" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="10.0.2" />
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="10.0.2" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="10.0.2" />
    <PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="10.0.2" />
    <PackageReference Include="Microsoft.Windows.SDK.BuildTools" Version="10.0.26100.7463" />
    <PackageReference Include="Microsoft.WindowsAppSDK" Version="1.8.260101001" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NavigationIntegrationSystem.Core\NavigationIntegrationSystem.Core.csproj" />
    <ProjectReference Include="..\NavigationIntegrationSystem.Devices\NavigationIntegrationSystem.Devices.csproj" />
    <ProjectReference Include="..\NavigationIntegrationSystem.Infrastructure\NavigationIntegrationSystem.Infrastructure.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Page Update="Views\Pages\SettingsPage.xaml">
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Page Update="Views\Controls\ShellHeaderControl.xaml">
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>

  <!--
    Defining the "HasPackageAndPublishMenuAddedByProject" property here allows the Solution
    Explorer "Package and Publish" context menu entry to be enabled for this project even if
    the Windows App SDK Nuget package has not yet been restored.
  -->
  <PropertyGroup Condition="'$(DisableHasPackageAndPublishMenuAddedByProject)'!='true' and '$(EnableMsixTooling)'=='true'">
    <HasPackageAndPublishMenu>true</HasPackageAndPublishMenu>
  </PropertyGroup>
</Project>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Package.appxmanifest
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>

<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">

  <Identity
    Name="37cc0a53-1655-45b3-a96f-90cebecbfca5"
    Publisher="CN=Bar Bichachi"
    Version="1.0.0.0" />

  <mp:PhoneIdentity PhoneProductId="37cc0a53-1655-45b3-a96f-90cebecbfca5" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>NavigationIntegrationSystem</DisplayName>
    <PublisherDisplayName>Bar Bichachi</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate"/>
  </Resources>

  <Applications>
    <Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="$targetentrypoint$">
      <uap:VisualElements
        DisplayName="NavigationIntegrationSystem"
        Description="NavigationIntegrationSystem"
        BackgroundColor="transparent"
        Square150x150Logo="Assets\Square150x150Logo.png"
        Square44x44Logo="Assets\Square44x44Logo.png">
        <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png"  Square71x71Logo="Assets\SmallTile.png" Square310x310Logo="Assets\LargeTile.png"/>
        <uap:SplashScreen Image="Assets\SplashScreen.png" />
      </uap:VisualElements>
    </Application>
  </Applications>

  <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Bootstrap\HostBuilderFactory.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.UI\Bootstrap\HostBuilderFactory.cs
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Recording;
using NavigationIntegrationSystem.Devices.Catalog;
using NavigationIntegrationSystem.Devices.Modules;
using NavigationIntegrationSystem.Devices.Runtime;
using NavigationIntegrationSystem.Infrastructure.Configuration.Paths;
using NavigationIntegrationSystem.Infrastructure.Configuration.Settings;
using NavigationIntegrationSystem.Infrastructure.Logging;
using NavigationIntegrationSystem.Infrastructure.Persistence.DevicesConfig;
using NavigationIntegrationSystem.Infrastructure.Recording;
using NavigationIntegrationSystem.UI.Services.Logging;
using NavigationIntegrationSystem.UI.Services.Recording;
using NavigationIntegrationSystem.UI.Services.UI.Dialog;
using NavigationIntegrationSystem.UI.Services.UI.Navigation;
using NavigationIntegrationSystem.UI.ViewModels;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Pages;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Pages;
using NavigationIntegrationSystem.UI.ViewModels.Settings;

namespace NavigationIntegrationSystem.UI.Bootstrap;

public static class HostBuilderFactory
{
    #region Public Methods
    public static IHost Build()
    {
        return Host.CreateDefaultBuilder()
            .ConfigureAppConfiguration((context, config) =>
            {
                config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: false);
            })
            .ConfigureServices((context, services) =>
            {
                // 1. Configuration & Persistence
                var settings = new AppSettings();
                context.Configuration.GetSection("Nis").Bind(settings.Nis);
                services.AddSingleton(settings);
                services.AddSingleton(new DevicesConfigService(AppPaths.DevicesConfigPath));

                // 2. Logging Infrastructure
                string logRoot = PathResolver.Resolve(settings.Nis.Log.Root);
                services.AddSingleton<ILogService>(sp => new FileLogService(logRoot));
                services.AddSingleton<ILogPaths>(sp => (ILogPaths)sp.GetRequiredService<ILogService>());
                services.AddSingleton(sp => new UiLogBuffer(sp.GetRequiredService<ILogService>(), settings.Nis.Log.MaxUiEntries));

                // 3. Device Domain & Management
                services.AddSingleton<InsDeviceRegistry>();
                services.AddSingleton<IInsDeviceRegistry>(sp => sp.GetRequiredService<InsDeviceRegistry>());
                services.AddSingleton<IInsDeviceInstanceProvider>(sp => sp.GetRequiredService<InsDeviceRegistry>());
                services.AddSingleton<DeviceCatalogService>();

                // 4. Device Modules (Factories)
                services.AddSingleton<IInsDeviceModule, Vn310DeviceModule>();
                services.AddSingleton<IInsDeviceModule, Tmaps100XDeviceModule>();
                services.AddSingleton<IInsDeviceModule, ManualDeviceModule>();
                services.AddSingleton<DevicesModuleBootstrapper>();

                // 5. Recording & Snapshot Services
                services.AddSingleton<IRecordingService, NisRecordingService>();
                services.AddSingleton<IntegrationSnapshotService>();
                services.AddSingleton<CsvTestingService>();

                // 6. UI Navigation & Support
                services.AddSingleton<IDialogService, DialogService>();
                services.AddSingleton<NavigationService>();

                // 7. ViewModels (All Singletons to maintain state across pages)
                services.AddSingleton<MainViewModel>();
                services.AddSingleton<DevicesViewModel>();
                services.AddSingleton<IntegrationViewModel>();
                services.AddSingleton<LogsViewModel>();
                services.AddSingleton<SettingsViewModel>();

                // 8. Shell
                services.AddSingleton<MainWindow>();
            })
            .Build();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\BoolToConnectTextConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Data;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts connection state boolean to Connect/Disconnect label
public sealed partial class BoolToConnectTextConverter : IValueConverter
{
    #region Functions
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool isConnected = value is bool b && b;
        return isConnected ? "Disconnect" : "Connect";
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language) { return false; }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\BoolToVisibilityConverter.cs
// ---------------------------------------------------------


using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts boolean to Visibility
public sealed partial class BoolToVisibilityConverter : IValueConverter
{
    #region Functions
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool isVisible = value is bool b && b;
        return isVisible ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        return value is Visibility visibility && visibility == Visibility.Visible;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\ConnectionKindToVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using NavigationIntegrationSystem.Devices.Enums;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts DeviceConnectionKind to Visibility using ConverterParameter (Udp/Tcp/Serial)
public sealed class ConnectionKindToVisibilityConverter : IValueConverter
{
    #region Functions
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not DeviceConnectionKind kind) { return Visibility.Collapsed; }
        if (parameter is not string targetKindText)  { return Visibility.Collapsed; }
        if (!Enum.TryParse(targetKindText, out DeviceConnectionKind targetKind)) { return Visibility.Collapsed; }

        return kind == targetKind ? Visibility.Visible : Visibility.Collapsed;
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language) { throw new NotSupportedException(); }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\DevicesPaneModeToVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using NavigationIntegrationSystem.UI.Enums;
using System;
namespace NavigationIntegrationSystem.UI.Converters;

// Converts DevicesPaneMode to Visibility for a specific pane type
public sealed class DevicesPaneModeToVisibilityConverter : IValueConverter
{
    #region Properties 
    public DevicesPaneMode TargetMode { get; set; } = DevicesPaneMode.None;
    #endregion

    #region Functions 
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is DevicesPaneMode mode && mode == TargetMode)
        { return Visibility.Visible; }
        return Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        return DevicesPaneMode.None;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\DeviceStatusToBrushConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using NavigationIntegrationSystem.Core.Enums;
using System;
using Windows.UI;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts DeviceStatus to a foreground brush for UI status display
public sealed class DeviceStatusToBrushConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not DeviceStatus status)
        {
            return new SolidColorBrush(Color.FromArgb(255, 128, 128, 128)); // fallback gray
        }

        return status switch
        {
            DeviceStatus.Connected => new SolidColorBrush(Color.FromArgb(255, 16, 124, 16)), // green

            DeviceStatus.Connecting => new SolidColorBrush(Color.FromArgb(255, 0, 120, 212)), // blue

            DeviceStatus.Error => new SolidColorBrush(Color.FromArgb(255, 196, 43, 28)), // red

            _ => new SolidColorBrush(Color.FromArgb(255, 128, 128, 128)) // disconnected / unknown
        };
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        throw new NotSupportedException();
    }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\InverseBoolToVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

public sealed class InverseBoolToVisibilityConverter : IValueConverter
{
    // Returns Collapsed if true, Visible if false
    public object Convert(object i_Value, Type i_TargetType, object i_Parameter, string i_Language)
    {
        if (i_Value is bool value) return value ? Visibility.Collapsed : Visibility.Visible;
        return Visibility.Visible;
    }

    public object ConvertBack(object i_Value, Type i_TargetType, object i_Parameter, string i_Language) => throw new NotImplementedException();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\LogLevelToBrushConverter.cs
// ---------------------------------------------------------

using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts log level string to a static badge brush
public sealed class LogLevelToBrushConverter : IValueConverter
{
    // Converts log level to brush
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        string level = value as string ?? string.Empty;

        return level.ToUpperInvariant() switch
        {
            "DEBUG" => new SolidColorBrush(Colors.Gray),
            "INFO" => new SolidColorBrush(ColorHelper.FromArgb(255, 45, 125, 255)),   // #2D7DFF
            "WARN" => new SolidColorBrush(ColorHelper.FromArgb(255, 244, 162, 97)),   // #F4A261
            "ERROR" => new SolidColorBrush(ColorHelper.FromArgb(255, 237, 85, 100)),  // #ED5564
            _ => new SolidColorBrush(Colors.DarkGray)
        };
    }

    // Not used
    public object ConvertBack(object value, Type targetType, object parameter, string language) { return value; }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\PaneModeToInspectVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using NavigationIntegrationSystem.UI.Enums;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Visible only when pane mode is Inspect
public sealed class PaneModeToInspectVisibilityConverter : IValueConverter
{
    #region Functions
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        return value is DevicesPaneMode mode && mode == DevicesPaneMode.Inspect ? Visibility.Visible : Visibility.Collapsed;
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language) { return DevicesPaneMode.None; }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\PaneModeToSettingsVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using NavigationIntegrationSystem.UI.Enums;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Visible only when pane mode is Settings
public sealed class PaneModeToSettingsVisibilityConverter : IValueConverter
{
    #region Functions
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        return value is DevicesPaneMode mode && mode == DevicesPaneMode.Settings ? Visibility.Visible : Visibility.Collapsed;
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language) { return DevicesPaneMode.None; }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\RecordingStatusToIconConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Data;

using System;

namespace NavigationIntegrationSystem.UI.Converters;

public sealed partial class RecordingStatusToIconConverter : IValueConverter
{
    // Converts recording state to symbol icon
    public object Convert(object value, Type targetType, object parameter, string language) =>
        (value is bool isRecording && isRecording) ? Symbol.Stop : Symbol.Video;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\RecordingStatusToTextConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Data;

using System;

namespace NavigationIntegrationSystem.UI.Converters;

public sealed partial class RecordingStatusToTextConverter : IValueConverter
{
    // Converts recording state to label
    public object Convert(object value, Type targetType, object parameter, string language) =>
        (value is bool isRecording && isRecording) ? "Stop Recording" : "Start Recording";
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Converters\StringNullOrEmptyToVisibilityConverter.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using System;

namespace NavigationIntegrationSystem.UI.Converters;

// Converts null or empty string to Collapsed, otherwise Visible
public sealed class StringNullOrEmptyToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is string s && !string.IsNullOrWhiteSpace(s))
        {
            return Visibility.Visible;
        }

        return Visibility.Collapsed;
    }

    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        throw new NotSupportedException();
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Enums\DevicesPaneMode.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.UI.Enums;

// Controls which right pane content is currently shown on the Devices page
public enum DevicesPaneMode
{
    None,
    Settings,
    Inspect
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Enums\DialogCloseDecision.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.UI.Enums;

// Represents a user's decision when closing a pane with unsaved changes
public enum DialogCloseDecision
{
    Apply,
    Discard,
    Cancel
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Navigation\NavKeys.cs
// ---------------------------------------------------------

namespace NavigationIntegrationSystem.UI.Navigation;

// Defines navigation route keys used across the UI
public static class NavKeys
{
    public const string Integration = "integration";
    public const string Devices = "devices";
    public const string Logs = "logs";
    public const string Settings = "settings";
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Properties\launchSettings.json
// ---------------------------------------------------------

{
  "profiles": {
    "NavigationIntegrationSystem (Package)": {
      "commandName": "MsixPackage"
    },
    "NavigationIntegrationSystem (Unpackaged)": {
      "commandName": "Project"
    }
  }
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\Logging\UiLogBuffer.cs
// ---------------------------------------------------------

using System.Collections.ObjectModel;

using Microsoft.UI.Dispatching;

using NavigationIntegrationSystem.Core.Logging;

namespace NavigationIntegrationSystem.UI.Services.Logging;

// Maintains a bounded UI log buffer and marshals updates to the UI thread
public sealed class UiLogBuffer
{
    #region Private Fields
    private readonly ILogService m_LogService;
    private readonly int m_MaxEntries;
    private DispatcherQueue? m_DispatcherQueue;
    #endregion

    #region Properties
    public ObservableCollection<UiLogEntry> Entries { get; } = new ObservableCollection<UiLogEntry>();
    #endregion

    #region Ctors
    public UiLogBuffer(ILogService i_LogService, int i_MaxEntries)
    {
        m_LogService = i_LogService;
        m_MaxEntries = i_MaxEntries <= 0 ? 2000 : i_MaxEntries;

        m_LogService.RecordWritten += OnRecordWritten;
    }
    #endregion

    #region Functions
    // Attaches dispatcher for UI-thread marshaling
    public void AttachUiDispatcher(DispatcherQueue i_DispatcherQueue)
    {
        if (m_DispatcherQueue != null) { return; }
        m_DispatcherQueue = i_DispatcherQueue;
    }

    // Clears the UI log buffer
    public void Clear()
    {
        if (m_DispatcherQueue == null || m_DispatcherQueue.HasThreadAccess) { Entries.Clear(); return; }
        m_DispatcherQueue.TryEnqueue(() => { Entries.Clear(); });
    }

    // Removes a single entry from the buffer
    public void Remove(UiLogEntry i_Entry)
    {
        if (m_DispatcherQueue == null || m_DispatcherQueue.HasThreadAccess) { Entries.Remove(i_Entry); return; }
        m_DispatcherQueue.TryEnqueue(() => { Entries.Remove(i_Entry); });
    }

    // Handles incoming log records from the logger
    private void OnRecordWritten(LogRecord i_Record)
    {
        var entry = new UiLogEntry(i_Record);

        if (m_DispatcherQueue == null || m_DispatcherQueue.HasThreadAccess) { Add(entry); return; }
        m_DispatcherQueue.TryEnqueue(() => { Add(entry); });
    }

    // Adds an entry and enforces bounded size
    private void Add(UiLogEntry i_Entry)
    {
        Entries.Add(i_Entry);
        if (Entries.Count > m_MaxEntries) { Entries.RemoveAt(0); }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\Logging\UiLogEntry.cs
// ---------------------------------------------------------

using System;

using NavigationIntegrationSystem.Core.Logging;

namespace NavigationIntegrationSystem.UI.Services.Logging;

// Represents a single log row displayed in the UI
public sealed class UiLogEntry
{
    #region Properties
    public DateTime TimestampLocal { get; }
    public string TimestampText => TimestampLocal.ToString("HH:mm:ss");
    public string Level { get; }
    public string Source { get; }
    public string Message { get; }
    #endregion

    #region Ctors
    public UiLogEntry(LogRecord i_Record)
    {
        TimestampLocal = i_Record.TimestampUtc.ToLocalTime();
        Level = i_Record.Level.ToString();
        Source = i_Record.Source;
        Message = string.IsNullOrWhiteSpace(i_Record.ExceptionText) ? i_Record.Message : $"{i_Record.Message}{Environment.NewLine}{i_Record.ExceptionText}";
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\Recording\CsvTestingService.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.UI\Services\Recording\CsvTestingService.cs
using System;
using System.IO;
using System.Text;
using NavigationIntegrationSystem.Core.Logging;
using Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

namespace NavigationIntegrationSystem.UI.Services.Recording;

public sealed class CsvTestingService : IDisposable
{
    private readonly ILogService m_LogService;
    private StreamWriter? m_CsvWriter;
    private bool m_IsRecording;

    public CsvTestingService(ILogService i_LogService)
    {
        m_LogService = i_LogService;
    }

    public void Start()
    {
        if (m_IsRecording) return;

        try
        {
            // Absolute fallback to ensure visibility
            string recPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Recordings");
            if (!Directory.Exists(recPath)) Directory.CreateDirectory(recPath);

            string filename = $"TestLog_{DateTime.Now:yyyyMMdd_HHmmss}.csv";
            string fullPath = Path.Combine(recPath, filename);

            // We use FileOptions.WriteThrough to force the OS to bypass all caches
            var fs = new FileStream(fullPath,
                                    FileMode.Create,
                                    FileAccess.Write,
                                    FileShare.ReadWrite,
                                    4096,
                                    FileOptions.WriteThrough);

            m_CsvWriter = new StreamWriter(fs, Encoding.UTF8);
            m_CsvWriter.AutoFlush = true; // Force flush on every WriteLine

            WriteHeader();
            m_IsRecording = true;

            m_LogService.Info(nameof(CsvTestingService), $"SUCCESS: CSV created at {fullPath}");
        }
        catch (Exception ex)
        {
            m_LogService.Error(nameof(CsvTestingService), "CRITICAL: CSV Start failed", ex);
        }
    }

    public void PrintSnapshot(IntegratedInsOutput_Data i_Data)
    {
        if (!m_IsRecording || m_CsvWriter == null) return;

        var sb = new StringBuilder();
        sb.Append($"{DateTime.Now:HH:mm:ss.fff},");

        // Helper to format the triplets (DeviceCode, ID, Value)
        Action<IntegratedValueTriplet> append = (t) => sb.Append($"{t.DeviceCode},{t.DeviceId},{t.Value:F8},");

        append(i_Data.PositionLat);
        append(i_Data.PositionLon);
        append(i_Data.PositionAlt);
        append(i_Data.EulerRoll);
        append(i_Data.EulerPitch);
        append(i_Data.EulerAzimuth);
        append(i_Data.VelocityNorth);
        append(i_Data.VelocityEast);
        append(i_Data.VelocityDown);

        m_CsvWriter.WriteLine(sb.ToString().TrimEnd(','));

        // Critical: Flush both the writer and the stream so the file appears in Explorer
        m_CsvWriter.Flush();
        m_CsvWriter.BaseStream.Flush();
    }

    private void WriteHeader()
    {
        m_CsvWriter?.WriteLine("Time,Lat_C,Lat_ID,Lat_V,Lon_C,Lon_ID,Lon_V,Alt_C,Alt_ID,Alt_V,Roll_C,Roll_ID,Roll_V,Pitch_C,Pitch_ID,Pitch_V,Azi_C,Azi_ID,Azi_V,VN_C,VN_ID,VN_V,VE_C,VE_ID,VE_V,VD_C,VD_ID,VD_V");
    }

    public void Stop()
    {
        if (!m_IsRecording) return;
        m_CsvWriter?.Dispose();
        m_CsvWriter = null;
        m_IsRecording = false;
    }

    public void Dispose() => Stop();
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\Recording\IntegrationSnapshotService.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.UI\Services\Recording\IntegrationSnapshotService.cs

using Infrastructure.Navigation.NavigationSystems.IntegratedInsOutput;

using Microsoft.UI.Dispatching;

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Recording;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Layout;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Pages;

using System;
using System.Linq;
using System.Runtime.InteropServices;

using static System.Runtime.InteropServices.JavaScript.JSType;

namespace NavigationIntegrationSystem.UI.Services.Recording;

public sealed class IntegrationSnapshotService : IDisposable
{
    #region Private Fields
    private readonly IRecordingService m_RecordingService;
    private readonly IInsDeviceInstanceProvider m_IdProvider;
    private readonly IntegrationViewModel m_IntegrationVm;
    private readonly CsvTestingService m_CsvTester;
    private DispatcherQueueTimer? m_SnapshotTimer;
    #endregion

    #region Constructors
    public IntegrationSnapshotService(
        IRecordingService i_RecordingService,
        IInsDeviceInstanceProvider i_IdProvider,
        IntegrationViewModel i_IntegrationVm,
        CsvTestingService i_CsvTester)
    {
        m_RecordingService = i_RecordingService;
        m_IdProvider = i_IdProvider;
        m_IntegrationVm = i_IntegrationVm;
        m_CsvTester = i_CsvTester;

        m_RecordingService.RecordingStateChanged += OnRecordingStateChanged;
    }
    #endregion

    #region Functions
    private void OnRecordingStateChanged(object? sender, bool i_IsRecording)
    {
        if (i_IsRecording)
        {
            m_CsvTester.Start();
            StartTimer();
        }
        else
        {
            StopTimer();
            m_CsvTester.Stop();
        }
    }

    private void StartTimer()
    {
        if (m_SnapshotTimer != null) return;

        // Ensure we are on the UI thread for VM access
        m_SnapshotTimer = DispatcherQueue.GetForCurrentThread().CreateTimer();
        m_SnapshotTimer.Interval = TimeSpan.FromMilliseconds(10); // 100Hz
        m_SnapshotTimer.Tick += (s, e) => TakeSnapshot();
        m_SnapshotTimer.Start();
    }

    private void StopTimer()
    {
        m_SnapshotTimer?.Stop();
        m_SnapshotTimer = null;
    }

    private void TakeSnapshot()
    {
        if (!m_RecordingService.IsRecording) return;

        IntegratedInsOutput_Data data = new IntegratedInsOutput_Data();

        foreach (IntegrationFieldRowViewModel row in m_IntegrationVm.Rows)
        {
            MapRowToData(row, data);
        }

        // Policy: Velocity Total is derived from components
        var vel = data.VelocityVector;
        double total = Math.Sqrt(vel.North * vel.North + vel.East * vel.East + vel.Down * vel.Down);

        // Metadata for Total follows the North component source
        data.VelocityTotalDeviceCode = data.VelocityNorthDeviceCode;
        data.VelocityTotalDeviceId = data.VelocityNorthDeviceId;

        m_RecordingService.RecordIntegratedOutput(data);
        m_CsvTester.PrintSnapshot(data);
    }

    // Core mapping entry point for a single row
    private void MapRowToData(IntegrationFieldRowViewModel i_Row, IntegratedInsOutput_Data io_Data)
    {
        IntegrationSourceCandidateViewModel? selected = i_Row.VisibleSources.FirstOrDefault(s => s.IsSelected);
        if (selected == null) return;

        ushort code = (ushort)selected.DeviceType;
        ushort id = selected.SourceDevice != null ? m_IdProvider.GetInstanceId(selected.SourceDevice) : (ushort)0;
        double val = (selected is NumericSourceCandidateViewModel numeric) ? numeric.Value :
                     (selected is ManualSourceCandidateViewModel manual) ? manual.Value : 0;

        // Route to specialized mapping sub-functions
        MapPositionFields(i_Row.FieldName, val, code, id, io_Data);
        MapEulerFields(i_Row.FieldName, val, code, id, io_Data);
        MapVelocityFields(i_Row.FieldName, val, code, id, io_Data);
        MapMiscFields(i_Row.FieldName, val, code, id, io_Data);
    }

    // Handles Latitude, Longitude, and Altitude
    private void MapPositionFields(string i_Name, double i_Val, ushort i_Code, ushort i_Id, IntegratedInsOutput_Data io_Data)
    {
        var pos = io_Data.Position;
        switch (i_Name)
        {
            case "Latitude":
                io_Data.LatitudeDeviceCode = i_Code; io_Data.LatitudeDeviceId = i_Id;
                pos.Lat = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.PositionLatValid;

                // Output Time Source is tied to Latitude selection by system policy
                io_Data.OutputTimeDeviceCode = i_Code;
                io_Data.OutputTimeDeviceId = i_Id;
                io_Data.OutputTime = DateTime.UtcNow;
                io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.OutputTimeValid;
                break;

            case "Longitude":
                io_Data.LongitudeDeviceCode = i_Code; io_Data.LongitudeDeviceId = i_Id;
                pos.Lon = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.PositionLonValid;
                break;

            case "Altitude":
                io_Data.AltitudeDeviceCode = i_Code; io_Data.AltitudeDeviceId = i_Id;
                pos.Alt = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.PositionAltValid;
                break;
        }
        io_Data.Position = pos;
    }

    // Handles Roll, Pitch, Azimuth and their respective Rates
    private void MapEulerFields(string i_Name, double i_Val, ushort i_Code, ushort i_Id, IntegratedInsOutput_Data io_Data)
    {
        var euler = io_Data.EulerData;
        switch (i_Name)
        {
            case "Roll":
                io_Data.RollDeviceCode = i_Code; io_Data.RollDeviceId = i_Id;
                euler.Angles.Roll = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.RollValid;
                break;
            case "Pitch":
                io_Data.PitchDeviceCode = i_Code; io_Data.PitchDeviceId = i_Id;
                euler.Angles.Pitch = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.PitchValid;
                break;
            case "Azimuth":
                io_Data.AzimuthDeviceCode = i_Code; io_Data.AzimuthDeviceId = i_Id;
                euler.Angles.Yaw = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.AzimuthValid;
                break;
            case "Roll Rate":
                io_Data.RollRateDeviceCode = i_Code; io_Data.RollRateDeviceId = i_Id;
                euler.Rates.Roll = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.RollRateValid;
                break;
            case "Pitch Rate":
                io_Data.PitchRateDeviceCode = i_Code; io_Data.PitchRateDeviceId = i_Id;
                euler.Rates.Pitch = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.PitchRateValid;
                break;
            case "Azimuth Rate":
                io_Data.AzimuthRateDeviceCode = i_Code; io_Data.AzimuthRateDeviceId = i_Id;
                euler.Rates.Yaw = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.AzimuthRateValid;
                break;
        }
        io_Data.EulerData = euler;
    }

    // Handles Velocity components and triggers Total Velocity validity
    private void MapVelocityFields(string i_Name, double i_Val, ushort i_Code, ushort i_Id, IntegratedInsOutput_Data io_Data)
    {
        var vel = io_Data.VelocityVector;
        bool isVelocityComponent = false;

        switch (i_Name)
        {
            case "Velocity North":
                io_Data.VelocityNorthDeviceCode = i_Code; io_Data.VelocityNorthDeviceId = i_Id;
                vel.North = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.VelocityNorthValid;
                isVelocityComponent = true;
                break;
            case "Velocity East":
                io_Data.VelocityEastDeviceCode = i_Code; io_Data.VelocityEastDeviceId = i_Id;
                vel.East = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.VelocityEastValid;
                isVelocityComponent = true;
                break;
            case "Velocity Down":
                io_Data.VelocityDownDeviceCode = i_Code; io_Data.VelocityDownDeviceId = i_Id;
                vel.Down = i_Val; io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.VelocityDownValid;
                isVelocityComponent = true;
                break;
        }

        if (isVelocityComponent)
        {
            io_Data.VelocityVector = vel;
            // Mark Total as valid since it is calculated from these components
            io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.VelocityTotalValid;
        }
    }

    // Handles Course and other miscellaneous protocol fields
    private void MapMiscFields(string i_Name, double i_Val, ushort i_Code, ushort i_Id, IntegratedInsOutput_Data io_Data)
    {
        switch (i_Name)
        {
            case "Course":
                io_Data.CourseDeviceCode = i_Code; io_Data.CourseDeviceId = i_Id;
                io_Data.Course = i_Val;
                io_Data.StatusValue |= (uint)IntegratedInsOutputStatusFlags.CourseValid;
                break;
        }
    }

    // Dispose pattern to clean up event subscription and timer resources
    public void Dispose()
    {
        m_RecordingService.RecordingStateChanged -= OnRecordingStateChanged;
        StopTimer();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\UI\Dialog\DialogService.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.UI.Enums;
using System;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.UI.Services.UI.Dialog;

// Handles user-facing dialogs
public sealed class DialogService : IDialogService
{
    #region Functions
    // Shows a confirmation dialog for unsaved changes
    public async Task<DialogCloseDecision> ShowUnsavedChangesDialogAsync(XamlRoot i_XamlRoot)
    {
        ContentDialog dialog = new ContentDialog
        {
            Title = "Unsaved changes",
            Content = "Changes won't take effect unless you apply them. What would you like to do?",
            PrimaryButtonText = "Apply",
            SecondaryButtonText = "Discard",
            CloseButtonText = "Cancel",
            DefaultButton = ContentDialogButton.Primary,
            XamlRoot = i_XamlRoot
        };

        ContentDialogResult result = await dialog.ShowAsync().AsTask();

        if (result == ContentDialogResult.Primary)
        { return DialogCloseDecision.Apply; }
        if (result == ContentDialogResult.Secondary)
        { return DialogCloseDecision.Discard; }

        return DialogCloseDecision.Cancel;
    }

    // Shows a validation-failed dialog with summary
    public async Task ShowValidationFailedDialogAsync(XamlRoot i_XamlRoot, string i_Summary)
    {
        ContentDialog dialog = new ContentDialog
        {
            Title = "Invalid settings",
            Content = i_Summary,
            CloseButtonText = "OK",
            DefaultButton = ContentDialogButton.Close,
            XamlRoot = i_XamlRoot
        };

        await dialog.ShowAsync().AsTask();
    }

    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\UI\Dialog\IDialogService.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using NavigationIntegrationSystem.UI.Enums;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.UI.Services.UI.Dialog;

// Provides application dialogs
public interface IDialogService
{
    Task<DialogCloseDecision> ShowUnsavedChangesDialogAsync(XamlRoot i_XamlRoot);

    Task ShowValidationFailedDialogAsync(XamlRoot i_XamlRoot, string i_Summary);
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Services\UI\Navigation\NavigationService.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.UI.Navigation;
using NavigationIntegrationSystem.UI.Views.Pages;

namespace NavigationIntegrationSystem.UI.Services.UI.Navigation;

// Centralizes page navigation so UI logic stays out of code-behind
public sealed class NavigationService
{
    #region Private Fields
    private Frame? m_Frame;
    #endregion

    #region Public Methods
    // Attaches the frame used for navigation
    public void Attach(Frame i_Frame) { m_Frame = i_Frame; }

    // Navigates to a page by key
    public void Navigate(string i_Key)
    {
        if (m_Frame == null) { return; }

        switch (i_Key)
        {
            case NavKeys.Integration: m_Frame.Navigate(typeof(IntegrationPage)); break;
            case NavKeys.Devices: m_Frame.Navigate(typeof(DevicesPage)); break;
            case NavKeys.Logs: m_Frame.Navigate(typeof(LogsPage)); break;
            case NavKeys.Settings: m_Frame.Navigate(typeof(SettingsPage)); break;
        }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\MainViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

using NavigationIntegrationSystem.Core.Recording;

namespace NavigationIntegrationSystem.UI.ViewModels;

// Owns top-level UI state for the app shell, including recording controls
public sealed partial class MainViewModel : ObservableObject
{
    #region Private Fields
    private readonly IRecordingService m_RecordingService;
    private bool m_IsRecording;
    #endregion

    #region Properties
    // Indicates if the system is currently recording data
    public bool IsRecording { get => m_IsRecording; private set => SetProperty(ref m_IsRecording, value); }
    #endregion

    #region Commands
    // Toggles the recording state
    public IRelayCommand ToggleRecordingCommand { get; }
    #endregion

    #region Constructors
    public MainViewModel(IRecordingService i_RecordingService)
    {
        m_RecordingService = i_RecordingService;
        m_IsRecording = m_RecordingService.IsRecording;

        ToggleRecordingCommand = new RelayCommand(OnToggleRecording);

        m_RecordingService.RecordingStateChanged += OnRecordingStateChanged;
    }
    #endregion

    #region Functions
    // Handles the UI request to start or stop recording
    private void OnToggleRecording()
    {
        if (m_RecordingService.IsRecording)
        {
            m_RecordingService.Stop();
        }
        else
        {
            m_RecordingService.Start();
        }
    }
    #endregion

    #region Event Handlers
    // Synchronizes the local property with the service state
    private void OnRecordingStateChanged(object? sender, bool i_IsRecording)
    {
        IsRecording = i_IsRecording;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Base\ViewModelBase.cs
// ---------------------------------------------------------

using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace NavigationIntegrationSystem.UI.ViewModels.Base;

// Base class for ViewModels with INotifyPropertyChanged and SetProperty support
public abstract partial class ViewModelBase : INotifyPropertyChanged
{
    #region Events
    public event PropertyChangedEventHandler? PropertyChanged;
    #endregion

    #region Protected Helpers
    // Raises PropertyChanged for the specified property name
    protected void OnPropertyChanged([CallerMemberName] string? i_PropertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(i_PropertyName));
    }

    // Sets a backing field and raises PropertyChanged when the value changes
    protected bool SetProperty<T>(ref T io_Field, T i_Value, [CallerMemberName] string? i_PropertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(io_Field, i_Value)) { return false; }
        io_Field = i_Value;
        OnPropertyChanged(i_PropertyName);
        return true;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Devices\Cards\DeviceCardViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Devices.Models;
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;

// Represents a single device card with status, config and actions for the Devices page
public sealed partial class DeviceCardViewModel : ObservableObject
{
    #region Private Fields
    private readonly ILogService m_LogService;
    private readonly IInsDevice m_Device;
    private readonly Action<DeviceCardViewModel> m_OpenSettings;
    private readonly Action<DeviceCardViewModel> m_OpenInspect;
    private bool m_HasUnsavedSettings;
    #endregion

    #region Properties
    public string DisplayName => m_Device.Definition.DisplayName;
    public IInsDevice Device => m_Device;
    public DeviceType Type => m_Device.Definition.Type;
    public DeviceConnectionSettings Connection => Config.Connection;
    public DeviceConfig Config { get; }
    public ObservableCollection<InspectFieldViewModel> InspectFields { get; }
    public DeviceStatus Status => m_Device.Status;
    public string? LastError => m_Device.LastError;
    public string ConnectButtonText => Status == DeviceStatus.Connected ? "Disconnect" : (Status == DeviceStatus.Connecting ? "Connecting..." : "Connect");
    public bool CanToggleConnect => Status != DeviceStatus.Connecting;
    public bool AutoReconnect
    {
        get => Config.AutoReconnect;
        set
        {
            if (Config.AutoReconnect == value) { return; }
            Config.AutoReconnect = value;
            OnPropertyChanged(nameof(AutoReconnect));
        }
    }
    public bool HasUnsavedSettings { get => m_HasUnsavedSettings; set => SetProperty(ref m_HasUnsavedSettings, value); }
    public ILogService LogService => m_LogService;
    public bool IsManual => Type == DeviceType.Manual;
    public bool ShowSettingsInspect => !IsManual;
    #endregion

    #region Commands
    public IAsyncRelayCommand ToggleConnectCommand { get; }
    public IRelayCommand OpenSettingsCommand { get; }
    public IRelayCommand OpenInspectCommand { get; }
    #endregion

    #region Constructors
    public DeviceCardViewModel(DeviceConfig i_Config, ILogService i_LogService, ObservableCollection<InspectFieldViewModel> i_InspectFields, Action<DeviceCardViewModel> i_OpenSettings, Action<DeviceCardViewModel> i_OpenInspect, IInsDevice i_Device)
    {
        Config = i_Config;
        InspectFields = i_InspectFields;
        m_LogService = i_LogService;
        m_OpenSettings = i_OpenSettings;
        m_OpenInspect = i_OpenInspect;
        m_Device = i_Device;
        m_Device.StateChanged += (_, _) =>
        {
            OnPropertyChanged(nameof(Status));
            OnPropertyChanged(nameof(LastError));
            OnPropertyChanged(nameof(ConnectButtonText));
            OnPropertyChanged(nameof(CanToggleConnect));
        };

        ToggleConnectCommand = new AsyncRelayCommand(OnToggleConnectAsync);
        OpenSettingsCommand = new RelayCommand(() => m_OpenSettings(this));
        OpenInspectCommand = new RelayCommand(() => m_OpenInspect(this));
    }
    #endregion

    #region Functions
    // Toggles the device connection state via the runtime device
    private async Task OnToggleConnectAsync()
    {
        if (Status == DeviceStatus.Connected)
        {
            m_LogService.Info(nameof(DeviceCardViewModel), $"{DisplayName} disconnect requested by user");
            await m_Device.DisconnectAsync();
            return;
        }

        if (Status == DeviceStatus.Connecting)
        {
            m_LogService.Info(nameof(DeviceCardViewModel), $"{DisplayName} connect canceled by user");
            await m_Device.DisconnectAsync();
            return;
        }

        m_LogService.Info(nameof(DeviceCardViewModel), $"{DisplayName} connect requested by user");
        await m_Device.ConnectAsync();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Devices\Cards\InspectFieldViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.ComponentModel;

namespace NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;

// Represents a single field row in the Inspect pane with a live value string
public sealed partial class InspectFieldViewModel : ObservableObject
{
    #region Private Fields
    private string m_ValueText;
    #endregion

    #region Properties
    public string Key { get; }
    public string Name { get; }
    public string Unit { get; }

    public string ValueText
    {
        get => m_ValueText;
        set => SetProperty(ref m_ValueText, value);
    }
    #endregion

    #region Ctors
    public InspectFieldViewModel(string i_Key, string i_Name, string i_Unit)
    {
        Key = i_Key;
        Name = i_Name;
        Unit = i_Unit;
        m_ValueText = string.Empty;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Devices\Pages\DevicesViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.Core.Models.Devices;
using NavigationIntegrationSystem.Devices.Catalog;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Runtime;
using NavigationIntegrationSystem.Infrastructure.Configuration.Paths;
using NavigationIntegrationSystem.Infrastructure.Persistence.DevicesConfig;
using NavigationIntegrationSystem.UI.Enums;
using NavigationIntegrationSystem.UI.Services.UI.Dialog;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Panes;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;

namespace NavigationIntegrationSystem.UI.ViewModels.Devices.Pages;

// Owns the Devices page state, including device cards and right-pane behavior
public sealed partial class DevicesViewModel : ObservableObject
{
    #region Private Fields
    private readonly DevicesConfigService m_ConfigService;
    private readonly DevicesConfigFile m_ConfigFile;
    private readonly ILogService m_LogService;
    private DeviceCardViewModel? m_SelectedDevice;
    private bool m_IsPaneOpen;
    private DevicesPaneMode m_PaneMode;
    private DeviceSettingsPaneViewModel? m_CurrentSettingsPane;
    private readonly IDialogService m_DialogService;
    private string m_SaveButtonText = "Save";
    private Symbol m_SaveButtonIcon = Symbol.Save;
    #endregion

    #region Properties
    public ObservableCollection<DeviceCardViewModel> Devices { get; } = new ObservableCollection<DeviceCardViewModel>();
    public DeviceCardViewModel? SelectedDevice { get => m_SelectedDevice; set => SetProperty(ref m_SelectedDevice, value);}
    public DevicesPaneMode PaneMode { get => m_PaneMode; set => SetProperty(ref m_PaneMode, value); }
    public DeviceSettingsPaneViewModel? CurrentSettingsPane { get => m_CurrentSettingsPane; set => SetProperty(ref m_CurrentSettingsPane, value); }
    public string SaveButtonText { get => m_SaveButtonText; private set => SetProperty(ref m_SaveButtonText, value); }
    public Symbol SaveButtonIcon { get => m_SaveButtonIcon; private set => SetProperty(ref m_SaveButtonIcon, value); }
    public bool CanSaveDevicesConfig { get => !IsPaneOpen; }

    public bool IsPaneOpen
    {
        get => m_IsPaneOpen;
        set
        {
            if (!SetProperty(ref m_IsPaneOpen, value)) { return; }
            OnPropertyChanged(nameof(CanSaveDevicesConfig));
        }
    }
    #endregion

    #region Commands
    public IRelayCommand<DeviceCardViewModel> OpenSettingsCommand { get; }
    public IRelayCommand<DeviceCardViewModel> OpenInspectCommand { get; }
    public IAsyncRelayCommand SaveDevicesConfigCommand { get; }
    public IRelayCommand ApplySettingsCommand { get; }
    #endregion

    #region Ctors
    public DevicesViewModel(DeviceCatalogService i_CatalogService, DevicesConfigService i_ConfigService, ILogService i_LogService, IDialogService i_DialogService, IInsDeviceRegistry i_DeviceRegistry)
    {
        m_ConfigService = i_ConfigService;
        m_LogService = i_LogService;
        m_DialogService = i_DialogService;
        m_ConfigFile = m_ConfigService.Load();

        m_IsPaneOpen = false;
        m_PaneMode = DevicesPaneMode.None;

        BuildDeviceCards(i_CatalogService, i_DeviceRegistry);

        OpenSettingsCommand = new RelayCommand<DeviceCardViewModel>(OnOpenSettings);
        OpenInspectCommand = new RelayCommand<DeviceCardViewModel>(OnOpenInspect);
        SaveDevicesConfigCommand = new AsyncRelayCommand(OnSaveConfigAsync);
        ApplySettingsCommand = new RelayCommand(OnApplySettings);
    }

    // Builds all device cards from the catalog and config
    private void BuildDeviceCards(DeviceCatalogService i_CatalogService, IInsDeviceRegistry i_DeviceRegistry)
    {
        Devices.Clear();

        // Create a device card for each device in the catalog
        foreach (DeviceDefinition def in i_CatalogService.GetDevices().OrderByDescending(d => d.Type == DeviceType.Manual).ThenBy(d => d.Type))
        {
            DeviceConfig cfg = m_ConfigService.GetOrCreateDevice(m_ConfigFile, def.Type);

            // Build inspect fields
            var fields = new ObservableCollection<InspectFieldViewModel>();
            foreach (var f in def.Fields)
            {
                fields.Add(new InspectFieldViewModel(f.Key, f.DisplayName, f.Unit));
            }

            // Create runtime device instance
            IInsDevice runtimeDevice = i_DeviceRegistry.Create(def, cfg);
            var vm = new DeviceCardViewModel(cfg, m_LogService, fields, OnOpenSettingsFromCard, OnOpenInspectFromCard, runtimeDevice);

            Devices.Add(vm);
        }
    }
    #endregion

    #region Functions
    // Opens the settings pane for a selected device
    private void OnOpenSettings(DeviceCardViewModel? i_Device)
    {
        if (i_Device == null) { return; }

        SelectedDevice = i_Device;
        CurrentSettingsPane = new DeviceSettingsPaneViewModel(this, i_Device);
        PaneMode = DevicesPaneMode.Settings;
        IsPaneOpen = true;
    }

    // Opens the inspect pane for a selected device
    private void OnOpenInspect(DeviceCardViewModel? i_Device)
    {
        if (i_Device == null) { return; }

        SelectedDevice = i_Device;
        CurrentSettingsPane = null;
        PaneMode = DevicesPaneMode.Inspect;
        IsPaneOpen = true;
    }

    // Closes the right pane
    public void ClosePane()
    {
        CurrentSettingsPane?.OnPaneClosing();

        IsPaneOpen = false;
        PaneMode = DevicesPaneMode.None;
        SelectedDevice = null;
        CurrentSettingsPane = null;
    }

    // Saves all device configuration changes to devices.json
    private async Task OnSaveConfigAsync()
    {
        m_ConfigService.Save(m_ConfigFile);
        foreach (var device in Devices) { device.HasUnsavedSettings = false; }
        m_LogService.Info(nameof(DevicesViewModel), $"Saved devices config: {AppPaths.DevicesConfigPath}");

        await ShowSavedFeedbackAsync();
    }

    // Applies current settings pane changes if available
    private void OnApplySettings()
    {
        if (CurrentSettingsPane == null) { return; }
        CurrentSettingsPane.ApplyCommand.Execute(null);
    }

    // Returns true only when the open pane is Settings and there are unsaved changes
    public bool ShouldConfirmPaneClose()
    {
        if (!IsPaneOpen) { return false; }
        if (PaneMode != DevicesPaneMode.Settings) { return false; }
        if (CurrentSettingsPane == null) { return false; }

        return CurrentSettingsPane.HasUnsavedChanges;
    }

    // Forces close after dialog decision
    public void ForceClosePaneAfterDecision(DialogCloseDecision i_Decision)
    {
        if (PaneMode != DevicesPaneMode.Settings || CurrentSettingsPane == null) { ClosePane(); return; }

        switch (i_Decision)
        {
            case DialogCloseDecision.Apply:
                CurrentSettingsPane.TryApply();
                return;

            case DialogCloseDecision.Discard:
                CurrentSettingsPane.Discard();
                ClosePane();
                return;

            case DialogCloseDecision.Cancel:
                return;
        }
    }

    // Shows unsaved-changes dialog and returns user decision
    public async Task<DialogCloseDecision> ConfirmCloseSettingsAsync(XamlRoot i_XamlRoot)
    {
        return await m_DialogService.ShowUnsavedChangesDialogAsync(i_XamlRoot);
    }

    // Shows validation-failed dialog with summary
    public Task ShowValidationFailedAsync(XamlRoot i_XamlRoot, string i_Summary)
    {
        return m_DialogService.ShowValidationFailedDialogAsync(i_XamlRoot, i_Summary);
    }

    // Clears selection/pane state without touching IsPaneOpen (it already changed)
    private void CleanupPaneState()
    {
        PaneMode = DevicesPaneMode.None;
        SelectedDevice = null;
        CurrentSettingsPane = null;
    }

    // Closes the settings pane after a successful Apply without triggering the unsaved-changes dialog
    public void ForceClosePaneAfterApply()
    {
        IsPaneOpen = false;
        CleanupPaneState();
    }

    // Shows a short "Saved" feedback on the Save button
    private async Task ShowSavedFeedbackAsync()
    {
        SaveButtonText = "Saved";
        SaveButtonIcon = Symbol.Accept;

        await Task.Delay(1400);

        SaveButtonText = "Save";
        SaveButtonIcon = Symbol.Save;
    }

    // Opens settings pane for a device requested by the card
    private void OnOpenSettingsFromCard(DeviceCardViewModel i_Device) { OnOpenSettings(i_Device); }

    // Opens inspect pane for a device requested by the card
    private void OnOpenInspectFromCard(DeviceCardViewModel i_Device) { OnOpenInspect(i_Device); }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Devices\Panes\DeviceSettingsDraftViewModel.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Devices.Enums;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.UI.ViewModels.Base;

namespace NavigationIntegrationSystem.UI.ViewModels.Devices.Panes;

// Draft/form state for the settings pane (UI-only)
public sealed partial class DeviceSettingsDraftViewModel : ViewModelBase
{
    #region General (Private Fields)
    private bool m_AutoReconnect = true;
    private DeviceConnectionKind m_ConnectionKind = DeviceConnectionKind.Udp;
    #endregion

    #region UDP (Private Fields)
    private string m_UdpRemoteIp = "127.0.0.1";
    private string m_UdpRemotePortText = "5000";
    private int m_UdpRemotePort = 5000;
    private string m_UdpLocalIp = "0.0.0.0";
    private string m_UdpLocalPortText = "5000";
    private int m_UdpLocalPort = 5000;
    #endregion

    #region TCP (Private Fields)
    private string m_TcpHost = "127.0.0.1";
    private string m_TcpPortText = "5000";
    private int m_TcpPort = 5000;
    #endregion

    #region Serial (Private Fields)
    private SerialLineKind m_SerialLineKind = SerialLineKind.Rs232;
    private string m_SerialComPort = "COM1";
    private string m_SerialBaudRateText = "115200";
    private int m_SerialBaudRate = 115200;
    #endregion

    #region Properties
    public bool AutoReconnect { get => m_AutoReconnect; set => SetProperty(ref m_AutoReconnect, value); }

    public DeviceConnectionKind ConnectionKind
    {
        get => m_ConnectionKind;
        set
        {
            if (!SetProperty(ref m_ConnectionKind, value)) { return; }
            OnPropertyChanged(nameof(IsUdpSelected));
            OnPropertyChanged(nameof(IsTcpSelected));
            OnPropertyChanged(nameof(IsSerialSelected));
        }
    }

    public string UdpRemoteIp { get => m_UdpRemoteIp; set => SetProperty(ref m_UdpRemoteIp, value); }
    public int UdpRemotePort { get => m_UdpRemotePort; set => SetProperty(ref m_UdpRemotePort, value); }
    public string UdpRemotePortText { get => m_UdpRemotePortText; set { if (SetProperty(ref m_UdpRemotePortText, value)) { if (int.TryParse(value, out int port)) { UdpRemotePort = port; } } } }
    public string UdpLocalIp { get => m_UdpLocalIp; set => SetProperty(ref m_UdpLocalIp, value); }
    public int UdpLocalPort { get => m_UdpLocalPort; set => SetProperty(ref m_UdpLocalPort, value); }
    public string UdpLocalPortText { get => m_UdpLocalPortText; set { if (SetProperty(ref m_UdpLocalPortText, value)) { if (int.TryParse(value, out int port)) { UdpLocalPort = port; } } } }

    public string TcpHost { get => m_TcpHost; set => SetProperty(ref m_TcpHost, value); }
    public int TcpPort { get => m_TcpPort; set => SetProperty(ref m_TcpPort, value); }
    public string TcpPortText { get => m_TcpPortText; set { if (SetProperty(ref m_TcpPortText, value)) { if (int.TryParse(value, out int port)) { TcpPort = port; } } } }

    public SerialLineKind SerialLineKind { get => m_SerialLineKind; set => SetProperty(ref m_SerialLineKind, value); }
    public string SerialComPort { get => m_SerialComPort; set => SetProperty(ref m_SerialComPort, value); }
    public int SerialBaudRate { get => m_SerialBaudRate; set => SetProperty(ref m_SerialBaudRate, value); }
    public string SerialBaudRateText { get => m_SerialBaudRateText; set { if (SetProperty(ref m_SerialBaudRateText, value)) { if (int.TryParse(value, out int rate)) { SerialBaudRate = rate; } } } }
    #endregion

    #region Derived UI State
    public bool IsUdpSelected { get => ConnectionKind == DeviceConnectionKind.Udp; }
    public bool IsTcpSelected { get => ConnectionKind == DeviceConnectionKind.Tcp; }
    public bool IsSerialSelected { get => ConnectionKind == DeviceConnectionKind.Serial; }
    #endregion

    #region Functions
    // Loads draft values from a persisted device config
    public void LoadFrom(DeviceConfig i_Config)
    {
        if (i_Config == null) { return; }

        AutoReconnect = i_Config.AutoReconnect;

        if (i_Config.Connection == null) { i_Config.Connection = new DeviceConnectionSettings(); }
        LoadFrom(i_Config.Connection);
    }

    // Loads draft values from persisted connection settings
    public void LoadFrom(DeviceConnectionSettings i_Settings)
    {
        if (i_Settings == null) { return; }

        ConnectionKind = i_Settings.Kind;

        UdpRemoteIp = i_Settings.Udp.RemoteIp;
        UdpRemotePort = i_Settings.Udp.RemotePort;
        UdpRemotePortText = UdpRemotePort.ToString();
        UdpLocalIp = i_Settings.Udp.LocalIp;
        UdpLocalPort = i_Settings.Udp.LocalPort;
        UdpLocalPortText = UdpLocalPort.ToString();

        TcpHost = i_Settings.Tcp.Host;
        TcpPort = i_Settings.Tcp.Port;
        TcpPortText = TcpPort.ToString();

        SerialLineKind = i_Settings.Serial.SerialLineKind;
        SerialComPort = i_Settings.Serial.ComPort;
        SerialBaudRate = i_Settings.Serial.BaudRate;
        SerialBaudRateText = SerialBaudRate.ToString();
    }

    // Applies draft values into an existing persisted device config (deep, safe)
    public void ApplyTo(DeviceConfig io_Config)
    {
        if (io_Config == null) { return; }

        io_Config.AutoReconnect = AutoReconnect;

        if (io_Config.Connection == null) { io_Config.Connection = new DeviceConnectionSettings(); }
        ApplyTo(io_Config.Connection);
    }

    // Applies draft values into persisted connection settings (deep, safe)
    public void ApplyTo(DeviceConnectionSettings io_Settings)
    {
        if (io_Settings == null) { return; }

        io_Settings.Kind = ConnectionKind;

        if (io_Settings.Udp == null) { io_Settings.Udp = new(); }
        if (io_Settings.Tcp == null) { io_Settings.Tcp = new(); }
        if (io_Settings.Serial == null) { io_Settings.Serial = new(); }

        io_Settings.Udp.RemoteIp = UdpRemoteIp;
        io_Settings.Udp.RemotePort = UdpRemotePort;
        io_Settings.Udp.LocalIp = UdpLocalIp;
        io_Settings.Udp.LocalPort = UdpLocalPort;

        io_Settings.Tcp.Host = TcpHost;
        io_Settings.Tcp.Port = TcpPort;

        io_Settings.Serial.SerialLineKind = SerialLineKind;
        io_Settings.Serial.ComPort = SerialComPort;
        io_Settings.Serial.BaudRate = SerialBaudRate;
    }

    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Devices\Panes\DeviceSettingsPaneViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.Input;
using Microsoft.UI.Xaml;
using NavigationIntegrationSystem.Devices.Enums;
using NavigationIntegrationSystem.Devices.Models;
using NavigationIntegrationSystem.Devices.Validation;
using NavigationIntegrationSystem.UI.ViewModels.Base;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Pages;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace NavigationIntegrationSystem.UI.ViewModels.Devices.Panes;

// ViewModel for the settings pane of a selected device (draft-based)
public sealed partial class DeviceSettingsPaneViewModel : ViewModelBase
{
    #region Private Fields
    private readonly DevicesViewModel m_Parent;
    private readonly DeviceCardViewModel m_Device;
    private DeviceConfig m_OriginalSnapshot;
    private bool m_HasUnsavedChanges;
    private bool m_IsLoadingDraft;
    private bool m_IsSubscribed;
    private XamlRoot? m_XamlRoot;
    #endregion

    #region Properties
    public DeviceCardViewModel Device { get => m_Device; }
    public DeviceSettingsDraftViewModel Draft { get; }
    public ObservableCollection<DeviceConnectionKind> ConnectionKinds { get; } = new ObservableCollection<DeviceConnectionKind>((DeviceConnectionKind[])Enum.GetValues(typeof(DeviceConnectionKind)));
    public ObservableCollection<SerialLineKind> SerialLineKinds { get; } = new ObservableCollection<SerialLineKind>((SerialLineKind[])Enum.GetValues(typeof(SerialLineKind)));
    public bool HasUnsavedChanges { get => m_HasUnsavedChanges; private set => SetProperty(ref m_HasUnsavedChanges, value); }
    #endregion

    #region Commands
    public IRelayCommand ApplyCommand { get; }
    public IRelayCommand DiscardCommand { get; }
    #endregion

    #region Ctors
    public DeviceSettingsPaneViewModel(DevicesViewModel i_Parent, DeviceCardViewModel i_Device)
    {
        m_Parent = i_Parent;
        m_Device = i_Device;

        Draft = new DeviceSettingsDraftViewModel();

        ApplyCommand = new RelayCommand(() => _ = TryApply());
        DiscardCommand = new RelayCommand(OnDiscard);

        m_OriginalSnapshot = m_Device.Config.DeepClone();

        LoadDraftFromSnapshot();
        SubscribeDraft();

        HasUnsavedChanges = false;
        m_Device.HasUnsavedSettings = false;
    }
    #endregion

    #region Functions
    // Receives XamlRoot from the view (for dialogs)
    public void SetXamlRoot(XamlRoot i_XamlRoot) { m_XamlRoot = i_XamlRoot; }

    // Applies draft into real config only if valid, returns success
    public bool TryApply()
    {
        var tempConfig = m_OriginalSnapshot.DeepClone();
        Draft.ApplyTo(tempConfig);

        var errors = ConnectionSettingsValidator.Validate(tempConfig.Connection);

        if (errors.Count > 0)
        {
            LogValidationFailure(errors);
            ShowValidationSummary(errors);
            return false;
        }

        Draft.ApplyTo(m_Device.Config);

        m_Parent.SaveDevicesConfigCommand.Execute(null);

        m_OriginalSnapshot = m_Device.Config.DeepClone();

        UnsubscribeDraft();

        HasUnsavedChanges = false;
        m_Device.HasUnsavedSettings = false;

        m_Parent.ForceClosePaneAfterApply();
        return true;
    }

    // Discards draft changes and restores from original snapshot
    public void Discard()
    {
        LoadDraftFromSnapshot();

        HasUnsavedChanges = false;
        m_Device.HasUnsavedSettings = false;
    }

    // Loads the draft from the original snapshot without triggering dirty
    private void LoadDraftFromSnapshot()
    {
        UnsubscribeDraft();

        m_IsLoadingDraft = true;
        Draft.LoadFrom(m_OriginalSnapshot);
        m_IsLoadingDraft = false;

        SubscribeDraft();
        UpdateDirtyState();
    }

    // Handles draft changes and updates dirty state based on snapshot-diff
    private void OnDraftPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (m_IsLoadingDraft) { return; }
        UpdateDirtyState();
    }

    // Updates HasUnsavedChanges based on snapshot diff + numeric editor state (empty/invalid text)
    private void UpdateDirtyState()
    {
        bool isDirty = IsDraftDirtyAgainstSnapshot();
        SetDirtyState(isDirty);
    }

    // Returns true when draft differs from original snapshot, including empty/invalid numeric text edits
    private bool IsDraftDirtyAgainstSnapshot()
    {
        DeviceConfig tempConfig = m_OriginalSnapshot.DeepClone();
        Draft.ApplyTo(tempConfig);

        if (!AreEquivalent(tempConfig, m_OriginalSnapshot)) { return true; }
        if (HasNumericTextEditsComparedToSnapshot()) { return true; }

        return false;
    }

    // Compares only what we persist for this device
    private static bool AreEquivalent(DeviceConfig i_A, DeviceConfig i_B)
    {
        if (i_A.AutoReconnect != i_B.AutoReconnect) { return false; }

        if (i_A.Connection.Kind != i_B.Connection.Kind) { return false; }

        // TCP
        if (i_A.Connection.Tcp.Host != i_B.Connection.Tcp.Host) { return false; }
        if (i_A.Connection.Tcp.Port != i_B.Connection.Tcp.Port) { return false; }

        // UDP
        if (i_A.Connection.Udp.RemoteIp != i_B.Connection.Udp.RemoteIp) { return false; }
        if (i_A.Connection.Udp.RemotePort != i_B.Connection.Udp.RemotePort) { return false; }
        if (i_A.Connection.Udp.LocalIp != i_B.Connection.Udp.LocalIp) { return false; }
        if (i_A.Connection.Udp.LocalPort != i_B.Connection.Udp.LocalPort) { return false; }

        // Serial
        if (i_A.Connection.Serial.SerialLineKind != i_B.Connection.Serial.SerialLineKind) { return false; }
        if (i_A.Connection.Serial.ComPort != i_B.Connection.Serial.ComPort) { return false; }
        if (i_A.Connection.Serial.BaudRate != i_B.Connection.Serial.BaudRate) { return false; }

        return true;
    }

    // Returns true if any numeric textbox is empty/invalid or doesn't match the snapshot value
    private bool HasNumericTextEditsComparedToSnapshot()
    {
        return !IsNumericTextEquivalent(Draft.TcpPortText, m_OriginalSnapshot.Connection.Tcp.Port)
            || !IsNumericTextEquivalent(Draft.UdpRemotePortText, m_OriginalSnapshot.Connection.Udp.RemotePort)
            || !IsNumericTextEquivalent(Draft.UdpLocalPortText, m_OriginalSnapshot.Connection.Udp.LocalPort)
            || !IsNumericTextEquivalent(Draft.SerialBaudRateText, m_OriginalSnapshot.Connection.Serial.BaudRate);
    }

    // Checks if numeric editor text represents the same value as the persisted snapshot
    private static bool IsNumericTextEquivalent(string i_Text, int i_Value)
    {
        if (string.IsNullOrWhiteSpace(i_Text)) { return false; }
        if (!int.TryParse(i_Text, out int parsed)) { return false; }
        return parsed == i_Value;
    }

    // Applies dirty state to both the pane and the card (single source of truth)
    private void SetDirtyState(bool i_IsDirty)
    {
        HasUnsavedChanges = i_IsDirty;
        m_Device.HasUnsavedSettings = i_IsDirty;
    }

    // Logs validation errors once per apply attempt
    private void LogValidationFailure(IReadOnlyList<string> i_Errors)
    {
        string summary = string.Join("; ", i_Errors);
        m_Device.LogService.Warn(nameof(DeviceSettingsPaneViewModel), $"Validation failed for {m_Device.DisplayName}: {summary}");
    }

    // Shows a short dialog summary (first error + count)
    private async void ShowValidationSummary(IReadOnlyList<string> i_Errors)
    {
        if (m_XamlRoot == null) { return; }

        string first = i_Errors.Count > 0 ? i_Errors[0] : "Invalid settings";
        string summary = i_Errors.Count == 1 ? first : $"{first}\n(+{i_Errors.Count - 1} more)";

        try { await m_Parent.ShowValidationFailedAsync(m_XamlRoot, summary); }
        catch (Exception ex) { m_Device.LogService.Error(nameof(DeviceSettingsPaneViewModel), "Failed showing validation dialog", ex); }

    }

    // Attaches Draft.PropertyChanged once
    private void SubscribeDraft()
    {
        if (m_IsSubscribed) { return; }
        Draft.PropertyChanged += OnDraftPropertyChanged;
        m_IsSubscribed = true;
    }

    // Detaches Draft.PropertyChanged once
    private void UnsubscribeDraft()
    {
        if (!m_IsSubscribed) { return; }
        Draft.PropertyChanged -= OnDraftPropertyChanged;
        m_IsSubscribed = false;
    }

    // Cleans up event handlers so late UI updates won't re-mark dirty after pane closes
    public void OnPaneClosing()
    {
        UnsubscribeDraft();
    }

    // Discard command handler
    private void OnDiscard() { Discard(); }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Candidates\IntegrationCandidateTemplateSelector.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;

// Selects the correct template for an integration source candidate
public sealed partial class IntegrationCandidateTemplateSelector : DataTemplateSelector
{
    #region Properties
    public DataTemplate? NumericTemplate { get; set; }
    public DataTemplate? ManualTemplate { get; set; }
    #endregion

    #region Overrides
    protected override DataTemplate SelectTemplateCore(object item)
    {
        return item switch
        {
            ManualSourceCandidateViewModel => ManualTemplate!,
            NumericSourceCandidateViewModel => NumericTemplate!,
            _ => base.SelectTemplateCore(item)
        };
    }

    protected override DataTemplate SelectTemplateCore(object item, DependencyObject container)
    {
        return SelectTemplateCore(item);
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Candidates\IntegrationSourceCandidateViewModel.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Base;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;

// Base VM for a per-row candidate source (device-provided or manual)
public abstract partial class IntegrationSourceCandidateViewModel : ViewModelBase
{
    #region Private Fields
    private bool m_IsSelected;
    #endregion

    #region Properties
    public DeviceType DeviceType { get; }
    public string DisplayName { get; }
    public abstract string DisplayText { get; }
    public bool IsSelected { get => m_IsSelected; private set => SetProperty(ref m_IsSelected, value); }
    public IInsDevice? SourceDevice { get; protected set; }
    #endregion

    #region Ctors
    protected IntegrationSourceCandidateViewModel(DeviceType i_DeviceType, string i_DisplayName)
    {
        DeviceType = i_DeviceType;
        DisplayName = i_DisplayName;
    }
    #endregion

    #region Functions
    // Sets selection state (owned by the row)
    internal void SetSelected(bool i_IsSelected) { IsSelected = i_IsSelected; }

    // Optional tick hook (manual does nothing)
    public virtual void Tick(double i_StepScale) { }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Candidates\ManualSourceCandidateViewModel.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;
using System.Globalization;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;

// Candidate backed by user input (numeric text)
public sealed partial class ManualSourceCandidateViewModel : IntegrationSourceCandidateViewModel
{
    #region Private Fields
    private string m_Text = string.Empty;
    private bool m_IsValid;
    private double m_Value;
    #endregion

    #region Properties
    public string Text
    {
        get => m_Text;
        set
        {
            if (!SetProperty(ref m_Text, value)) { return; }
            Validate();
            OnPropertyChanged(nameof(DisplayText));
        }
    }

    public bool IsValid { get => m_IsValid; private set => SetProperty(ref m_IsValid, value); }

    public double Value => m_Value;

    public override string DisplayText
    {
        get
        {
            if (string.IsNullOrWhiteSpace(Text)) { return "—"; }
            if (!IsValid) { return "Invalid"; }
            return Text.Trim();
        }
    }
    #endregion

    #region Ctors
    public ManualSourceCandidateViewModel(string i_DisplayName) : base(DeviceType.Manual, i_DisplayName)
    {
        SourceDevice = null;
        Validate();
    }
    #endregion

    #region Functions
    // Validates Text and forces DisplayText update
    private void Validate()
    {
        if (string.IsNullOrWhiteSpace(Text))
        {
            m_Value = 0;
            IsValid = true;
            return;
        }

        IsValid = double.TryParse(Text, NumberStyles.Any, CultureInfo.InvariantCulture, out m_Value);
        OnPropertyChanged(nameof(DisplayText));
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Candidates\NumericSourceCandidateViewModel.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Devices;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;

using System;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;

// Candidate backed by a numeric value (dummy telemetry for now)
public sealed partial class NumericSourceCandidateViewModel : IntegrationSourceCandidateViewModel
{
    #region Private Fields
    private readonly Random m_Rng;
    private double m_Value;
    #endregion

    #region Properties
    public double Value
    {
        get => m_Value;
        set { if (!SetProperty(ref m_Value, value)) { return; } OnPropertyChanged(nameof(DisplayText)); }
    }

    public override string DisplayText => $"{Value:0.00000}";
    #endregion

    #region Ctors
    public NumericSourceCandidateViewModel(IInsDevice i_Device, string i_DisplayName, double i_InitialValue, Random i_Rng)
        : base(i_Device.Definition.Type, i_DisplayName)
    {
        SourceDevice = i_Device;
        m_Value = i_InitialValue;
        m_Rng = i_Rng;
    }
    #endregion

    #region Functions
    // Updates the value with a small random delta (dummy telemetry)
    public override void Tick(double i_StepScale)
    {
        double delta = (m_Rng.NextDouble() - 0.5) * i_StepScale;
        Value += delta;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Layout\IntegrationDeviceOptionViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.Input;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Base;
using System;
using System.Windows.Input;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Layout;

// Represents a device option in the Integration header (visibility toggle + apply-to-all)
public sealed partial class IntegrationDeviceOptionViewModel : ViewModelBase
{
    #region Private Fields
    private bool m_IsVisible;
    #endregion

    #region Properties
    public DeviceType DeviceType { get; }
    public string DisplayName { get; }

    public bool IsVisible
    {
        get => m_IsVisible;
        set
        {
            if (!SetProperty(ref m_IsVisible, value)) { return; }
            VisibilityChanged?.Invoke(this, EventArgs.Empty);
        }
    }
    #endregion

    #region Events
    public event EventHandler? VisibilityChanged;
    public event EventHandler? ApplyToAllRequested;
    #endregion

    #region Commands
    public ICommand ApplyToAllFieldsCommand { get; }
    #endregion

    #region Constructors
    public IntegrationDeviceOptionViewModel(DeviceType i_DeviceType, string i_DisplayName, bool i_IsVisible)
    {
        DeviceType = i_DeviceType;
        DisplayName = i_DisplayName;
        m_IsVisible = i_IsVisible;

        ApplyToAllFieldsCommand = new RelayCommand(() => ApplyToAllRequested?.Invoke(this, EventArgs.Empty));
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Layout\IntegrationFieldRowViewModel.cs
// ---------------------------------------------------------

using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Base;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Layout;

// Represents a single integration field row (parameter + selectable sources)
public sealed partial class IntegrationFieldRowViewModel : ViewModelBase
{
    #region Private Fields
    private IntegrationSourceCandidateViewModel? m_SelectedSource;
    private double m_CalculatedValue;
    #endregion

    #region Properties
    public string FieldName { get; }
    public string Unit { get; }

    public ObservableCollection<IntegrationSourceCandidateViewModel> Sources { get; } = [];
    public ObservableCollection<IntegrationSourceCandidateViewModel> VisibleSources { get; } = [];

    public DeviceType? SelectedDeviceType => m_SelectedSource?.DeviceType;

    public bool IsOutputEmpty => m_SelectedSource == null || !VisibleSources.Contains(m_SelectedSource);
    public bool IsCalculated { get => FieldName.Contains("Velocity Total"); }

    public string SelectedValueText
    {
        get
        {
            if (IsCalculated) return $"{m_CalculatedValue:0.00000}";
            if (m_SelectedSource == null || !VisibleSources.Contains(m_SelectedSource)) return "—";
            return m_SelectedSource.DisplayText;
        }
    }
    #endregion

    #region Constructors
    public IntegrationFieldRowViewModel(string i_FieldName, string i_Unit)
    {
        FieldName = i_FieldName;
        Unit = i_Unit;
    }
    #endregion

    #region Functions
    // Rebuilds visible sources and keeps selection valid
    public void RefreshVisibleSources(Func<IntegrationSourceCandidateViewModel, bool> i_IsVisible)
    {
        VisibleSources.Clear();
        if (IsCalculated) return;

        foreach (IntegrationSourceCandidateViewModel src in Sources)
        {
            if (!i_IsVisible(src)) { continue; }
            VisibleSources.Add(src);
        }

        EnforceValidSelection();
        SyncSelectionFlags();
        OnPropertyChanged(nameof(SelectedValueText));
        OnPropertyChanged(nameof(IsOutputEmpty));
    }

    // Selects a source (row-owned selection)
    public void SelectSource(IntegrationSourceCandidateViewModel i_Source)
    {
        if (i_Source == null) { return; }
        if (ReferenceEquals(i_Source, m_SelectedSource)) { return; }

        SetSelectedSource(i_Source);

        SyncSelectionFlags();
        OnPropertyChanged(nameof(SelectedValueText));
        OnPropertyChanged(nameof(IsOutputEmpty));
    }

    // Restores selection by DeviceType if possible
    public void RestoreSelection(DeviceType? i_PreviousDeviceType)
    {
        if (i_PreviousDeviceType == null) { EnforceValidSelection(); return; }

        IntegrationSourceCandidateViewModel? match = VisibleSources.FirstOrDefault(s => s.DeviceType == i_PreviousDeviceType);
        if (match != null) { SelectSource(match); return; }

        EnforceValidSelection();
    }

    // Ensures there is always a valid selection
    private void EnforceValidSelection()
    {
        if (m_SelectedSource != null && VisibleSources.Contains(m_SelectedSource)) { return; }

        IntegrationSourceCandidateViewModel? fallback = VisibleSources.FirstOrDefault();
        if (fallback != null) { SetSelectedSource(fallback); return; }

        ClearSelectedSource();
    }

    // Sets the selected source and manages subscriptions in one place
    private void SetSelectedSource(IntegrationSourceCandidateViewModel i_Source)
    {
        if (m_SelectedSource != null) { m_SelectedSource.PropertyChanged -= OnSelectedSourceChanged; }

        m_SelectedSource = i_Source;
        m_SelectedSource.PropertyChanged += OnSelectedSourceChanged;
    }

    // Clears selection and unsubscribes safely
    private void ClearSelectedSource()
    {
        if (m_SelectedSource == null) { return; }
        m_SelectedSource.PropertyChanged -= OnSelectedSourceChanged;
        m_SelectedSource = null;
    }

    // Keeps RadioButtons synced (selection state owned by row)
    private void SyncSelectionFlags()
    {
        foreach (IntegrationSourceCandidateViewModel src in Sources)
        {
            bool shouldBeSelected = ReferenceEquals(src, m_SelectedSource);
            if (src.IsSelected == shouldBeSelected) { continue; }
            src.SetSelected(shouldBeSelected);
        }
    }

    // Updates the calculated value for calculated fields and refreshes the display
    public void UpdateCalculatedValue(double i_Value)
    {
        m_CalculatedValue = i_Value;
        OnPropertyChanged(nameof(SelectedValueText));
    }
    #endregion

    #region Event Handlers
    // Keeps Integrated Output live when selected source value updates
    private void OnSelectedSourceChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(IntegrationSourceCandidateViewModel.DisplayText))
        {
            OnPropertyChanged(nameof(SelectedValueText));
        }
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Integration\Pages\IntegrationViewModel.cs
// ---------------------------------------------------------

using Microsoft.UI.Dispatching;
using NavigationIntegrationSystem.Core.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Base;
using NavigationIntegrationSystem.UI.ViewModels.Devices;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Pages;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Layout;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;

namespace NavigationIntegrationSystem.UI.ViewModels.Integration.Pages;

// Owns the Integration page state: header device toggles, per-row source selection, and dummy live updates
public sealed partial class IntegrationViewModel : ViewModelBase
{
    #region Private Fields
    private readonly DevicesViewModel m_DevicesViewModel;
    private readonly Random m_Rng = new();
    private readonly Dictionary<DeviceType, bool> m_DeviceVisibility = new();
    private DispatcherQueueTimer? m_Timer;
    #endregion

    #region Properties
    public ObservableCollection<IntegrationFieldRowViewModel> Rows { get; } = [];
    public ObservableCollection<IntegrationDeviceOptionViewModel> ConnectedDevices { get; } = [];
    #endregion

    #region Constructors
    public IntegrationViewModel(DevicesViewModel i_DevicesViewModel)
    {
        m_DevicesViewModel = i_DevicesViewModel;

        InitializeIntegrationRows();
        HookDevices();
        RebuildFromConnectedDevices();
    }
    #endregion

    #region Functions
    // Initializes the fixed set of integration rows based on the required output fields
    private void InitializeIntegrationRows()
    {
        // Position
        Rows.Add(new IntegrationFieldRowViewModel("Latitude", "deg"));
        Rows.Add(new IntegrationFieldRowViewModel("Longitude", "deg"));
        Rows.Add(new IntegrationFieldRowViewModel("Altitude", "m"));

        // Euler Angles
        Rows.Add(new IntegrationFieldRowViewModel("Roll", "deg"));
        Rows.Add(new IntegrationFieldRowViewModel("Pitch", "deg"));
        Rows.Add(new IntegrationFieldRowViewModel("Azimuth", "deg"));

        // Euler Rates
        Rows.Add(new IntegrationFieldRowViewModel("Roll Rate", "deg/s"));
        Rows.Add(new IntegrationFieldRowViewModel("Pitch Rate", "deg/s"));
        Rows.Add(new IntegrationFieldRowViewModel("Azimuth Rate", "deg/s"));

        // Velocity Components (Required for calculated Total)
        Rows.Add(new IntegrationFieldRowViewModel("Velocity North", "m/s"));
        Rows.Add(new IntegrationFieldRowViewModel("Velocity East", "m/s"));
        Rows.Add(new IntegrationFieldRowViewModel("Velocity Down", "m/s"));

        // Derived/Calculated Fields
        Rows.Add(new IntegrationFieldRowViewModel("Velocity Total (calc)", "m/s"));

        // Miscellaneous
        Rows.Add(new IntegrationFieldRowViewModel("Course", "deg"));
    }

    // Starts dummy live updates using DispatcherQueue
    public void Initialize(DispatcherQueue i_DispatcherQueue)
    {
        if (m_Timer != null) { return; }

        m_Timer = i_DispatcherQueue.CreateTimer();
        m_Timer.Interval = TimeSpan.FromMilliseconds(250);
        m_Timer.Tick += OnTimerTick;
        m_Timer.Start();
    }

    // Called by header option when visibility changes
    public void OnHeaderVisibilityChanged(DeviceType i_DeviceType, bool i_IsVisible)
    {
        m_DeviceVisibility[i_DeviceType] = i_IsVisible;

        RefreshAllRowsVisibility();

        if (i_IsVisible) { TryAutoSelectNewlyVisibleSource(i_DeviceType); }
    }

    // Applies a selected source for all rows (by device type)
    public void ApplyDeviceToAllFields(DeviceType i_DeviceType)
    {
        foreach (IntegrationFieldRowViewModel row in Rows)
        {
            IntegrationSourceCandidateViewModel? match = row.VisibleSources.FirstOrDefault(s => s.DeviceType == i_DeviceType);
            if (match != null) { row.SelectSource(match); }
        }
    }

    // Handles dummy telemetry tick
    private void OnTimerTick(DispatcherQueueTimer i_Sender, object i_Args) { Tick(); }

    // Updates dummy candidate values
    private void Tick()
    {
        foreach (IntegrationFieldRowViewModel row in Rows)
        {
            if (row.IsCalculated)
            {
                UpdateCalculatedRow(row);
                continue;
            }

            double step = GetStepScale(row.Unit, row.FieldName);
            foreach (IntegrationSourceCandidateViewModel src in row.Sources) { src.Tick(step); }
        }
    }

    // Logic to calculate the magnitude of the selected velocity components
    private void UpdateCalculatedRow(IntegrationFieldRowViewModel i_TotalRow)
    {
        var vnRow = Rows.FirstOrDefault(r => r.FieldName == "Velocity North");
        var veRow = Rows.FirstOrDefault(r => r.FieldName == "Velocity East");
        var vdRow = Rows.FirstOrDefault(r => r.FieldName == "Velocity Down");

        if (vnRow == null || veRow == null || vdRow == null) return;

        // Helper to get numeric value from a row's selected source
        Func<IntegrationFieldRowViewModel, double> getVal = (r) =>
        {
            var sel = r.VisibleSources.FirstOrDefault(s => s.IsSelected);
            if (sel is NumericSourceCandidateViewModel n) return n.Value;
            if (sel is ManualSourceCandidateViewModel m) return m.Value;
            return 0;
        };

        double vn = getVal(vnRow);
        double ve = getVal(veRow);
        double vd = getVal(vdRow);

        double total = Math.Sqrt(vn * vn + ve * ve + vd * vd);

        i_TotalRow.UpdateCalculatedValue(total);
    }

    // Rebuilds header + per-row sources based on current connected devices
    private void RebuildFromConnectedDevices()
    {
        DeviceCardViewModel[] connected = m_DevicesViewModel.Devices.Where(d => d.Status == DeviceStatus.Connected).ToArray();

        RebuildHeaderDevices(connected);
        RebuildRowSources(connected);

        RefreshAllRowsVisibility();
    }

    // Rebuilds header options from connected devices and preserves toggle state
    private void RebuildHeaderDevices(DeviceCardViewModel[] i_Connected)
    {
        ConnectedDevices.Clear();

        foreach (DeviceCardViewModel device in i_Connected)
        {
            bool isVisible = m_DeviceVisibility.TryGetValue(device.Type, out bool cached) ? cached : true;

            var opt = new IntegrationDeviceOptionViewModel(device.Type, device.DisplayName, isVisible);

            opt.VisibilityChanged += (_, _) => OnHeaderVisibilityChanged(opt.DeviceType, opt.IsVisible);
            opt.ApplyToAllRequested += (_, _) => ApplyDeviceToAllFields(opt.DeviceType);

            ConnectedDevices.Add(opt);
            m_DeviceVisibility[device.Type] = isVisible;
        }
    }

    // Rebuilds each row candidate list and restores selection by device type
    private void RebuildRowSources(DeviceCardViewModel[] i_Connected)
    {
        foreach (IntegrationFieldRowViewModel row in Rows)
        {
            DeviceType? previousDeviceType = row.SelectedDeviceType;

            row.Sources.Clear();
            foreach (DeviceCardViewModel device in i_Connected)
            {
                if (device.Type == DeviceType.Manual)
                {
                    row.Sources.Add(new ManualSourceCandidateViewModel(device.DisplayName));
                    continue;
                }

                double initial = CreateInitialValue(row.FieldName, row.Unit, device.Type);
                row.Sources.Add(new NumericSourceCandidateViewModel(device.Device, device.DisplayName, initial, m_Rng));
            }

            row.RestoreSelection(previousDeviceType);
        }
    }

    // Refreshes device visibility across all rows
    private void RefreshAllRowsVisibility()
    {
        foreach (IntegrationFieldRowViewModel row in Rows) { row.RefreshVisibleSources(IsCandidateVisible); }
    }

    // Candidate is visible only if its device is toggled visible in the header
    private bool IsCandidateVisible(IntegrationSourceCandidateViewModel i_Source)
    {
        return m_DeviceVisibility.TryGetValue(i_Source.DeviceType, out bool isVisible) && isVisible;
    }

    // Attempts to auto-select a newly visible device for rows that are currently "—"
    private void TryAutoSelectNewlyVisibleSource(DeviceType i_DeviceType)
    {
        foreach (IntegrationFieldRowViewModel row in Rows)
        {
            if (!row.IsOutputEmpty) { continue; }

            IntegrationSourceCandidateViewModel? match = row.VisibleSources.FirstOrDefault(s => s.DeviceType == i_DeviceType);
            if (match != null) { row.SelectSource(match); }
        }
    }

    // Hooks device status changes (connect/disconnect) and keeps integration rebuilt
    private void HookDevices()
    {
        if (m_DevicesViewModel.Devices is INotifyCollectionChanged cc) { cc.CollectionChanged += OnDevicesCollectionChanged; }
        foreach (DeviceCardViewModel device in m_DevicesViewModel.Devices) { device.PropertyChanged += OnDevicePropertyChanged; }
    }

    // Hooks added/removed devices
    private void OnDevicesCollectionChanged(object? i_Sender, NotifyCollectionChangedEventArgs i_E)
    {
        if (i_E.NewItems != null)
        {
            foreach (DeviceCardViewModel device in i_E.NewItems) { device.PropertyChanged += OnDevicePropertyChanged; }
        }

        if (i_E.OldItems != null)
        {
            foreach (DeviceCardViewModel device in i_E.OldItems) { device.PropertyChanged -= OnDevicePropertyChanged; }
        }

        RebuildFromConnectedDevices();
    }

    // Rebuilds only when Status changes
    private void OnDevicePropertyChanged(object? i_Sender, PropertyChangedEventArgs i_E)
    {
        if (i_E.PropertyName != nameof(DeviceCardViewModel.Status)) { return; }
        RebuildFromConnectedDevices();
    }

    // Returns appropriate random step size per unit/field
    private double GetStepScale(string i_Unit, string i_FieldName)
    {
        if (i_FieldName.Contains("Rate")) return 0.1;
        if (i_Unit == "deg" && (i_FieldName == "Latitude" || i_FieldName == "Longitude")) return 0.00005;
        if (i_Unit == "m") return 0.20;
        if (i_Unit == "m/s") return 0.15;
        return 0.05;
    }

    // Creates a dummy initial value per field/device-type so candidates look distinct
    private double CreateInitialValue(string i_FieldName, string i_Unit, DeviceType i_DeviceType)
    {
        double baseValue =
            i_FieldName switch
            {
                "Azimuth" => 8.0,
                "Elevation" => 1.25,
                "Latitude" => 32.0853,
                "Longitude" => 34.7818,
                "Altitude" => 120.5,
                "Pitch" => 0.2,
                "Roll" => -0.1,
                "Speed" => 52.1,
                _ => 0.0
            };

        double deviceOffset = i_DeviceType == DeviceType.VN310 ? 0.0 : 5.0;
        return baseValue + deviceOffset;
    }

    // Stops the dummy telemetry timer safely
    public void Deinitialize()
    {
        m_Timer?.Stop();
        m_Timer = null;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Logging\LogsViewModel.cs
// ---------------------------------------------------------

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.WinUI.Collections;
using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.Core.Logging;
using NavigationIntegrationSystem.UI.Services.Logging;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.Threading.Tasks;
using Windows.ApplicationModel.DataTransfer;
using Windows.Storage;
using Windows.System;
using DispatcherQueue = Microsoft.UI.Dispatching.DispatcherQueue;

namespace NavigationIntegrationSystem.UI.ViewModels;

// Exposes the live log buffer for UI binding and future log actions
public sealed partial class LogsViewModel : ObservableObject
{
    #region Private Fields
    private readonly UiLogBuffer m_LogBuffer;
    private readonly ILogPaths m_LogPaths;
    private DispatcherQueue? m_DispatcherQueue;
    private AdvancedCollectionView m_FilteredEntries;
    private IList<object>? m_SelectedItems;
    private string m_SearchText = string.Empty;
    private string m_SelectedLevel = "All";
    private string m_CopyButtonText = "Copy all";
    private string m_ClearButtonText = "Clear all";
    private string m_SelectAllButtonText = "Select all";
    private int m_LastSelectedCount;
    #endregion

    #region Properties
    public ObservableCollection<UiLogEntry> Entries => m_LogBuffer.Entries;
    public AdvancedCollectionView FilteredEntries => m_FilteredEntries;
    public string LogFolderPath => m_LogPaths.LogFolderPath;

    public string SearchText
    {
        get => m_SearchText;
        set
        {
            if (!SetProperty(ref m_SearchText, value)) { return; }
            FilteredEntries.Refresh();
            RequestSelectionClear();
        }
    }

    public string SelectedLevel
    {
        get => m_SelectedLevel;
        set
        {
            if (!SetProperty(ref m_SelectedLevel, value)) { return; }
            FilteredEntries.Refresh();
            RequestSelectionClear();
        }
    }

    public string CopyButtonText { get => m_CopyButtonText; private set => SetProperty(ref m_CopyButtonText, value); }
    public string ClearButtonText { get => m_ClearButtonText; private set => SetProperty(ref m_ClearButtonText, value); }
    public string SelectAllButtonText { get => m_SelectAllButtonText; private set => SetProperty(ref m_SelectAllButtonText, value); }
    public IList<object>? SelectedItems { get => m_SelectedItems; set => SetProperty(ref m_SelectedItems, value); }
    #endregion

    #region Commands
    public IAsyncRelayCommand<IList<object>?> CopyCommand { get; }
    public IRelayCommand<IList<object>?> ClearCommand { get; }
    public IRelayCommand<ListView?> ToggleSelectAllCommand { get; }
    public IAsyncRelayCommand OpenLogFolderCommand { get; }
    #endregion

    #region Events
    public event Action? RequestClearSelection;
    #endregion

    #region Ctors
    public LogsViewModel(UiLogBuffer i_LogBuffer, ILogPaths i_LogPaths)
    {
        m_LogBuffer = i_LogBuffer;
        m_LogPaths = i_LogPaths;

        m_FilteredEntries = new AdvancedCollectionView(m_LogBuffer.Entries, true);
        m_FilteredEntries.Filter = FilterLogEntry;

        CopyCommand = new AsyncRelayCommand<IList<object>?>(ExecuteCopyAsync);
        ClearCommand = new RelayCommand<IList<object>?>(ExecuteClear);
        ToggleSelectAllCommand = new RelayCommand<ListView?>(ExecuteToggleSelectAll);
        OpenLogFolderCommand = new AsyncRelayCommand(ExecuteOpenLogFolderAsync);

        UpdateSelectionButtons(0, m_FilteredEntries.Count);
    }
    #endregion

    #region Functions
    // Filters entries by current level and search text
    private bool FilterLogEntry(object i_Item)
    {
        if (i_Item is not UiLogEntry entry) { return false; }

        if (!string.Equals(SelectedLevel, "All", StringComparison.OrdinalIgnoreCase) &&
            !string.Equals(entry.Level, SelectedLevel, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        if (!string.IsNullOrWhiteSpace(SearchText))
        {
            if ((entry.Message?.IndexOf(SearchText, StringComparison.OrdinalIgnoreCase) ?? -1) < 0) { return false; }
        }

        return true;
    }

    // Copies selected rows (if any); otherwise copies all filtered rows, and shows "Copied"
    private async Task ExecuteCopyAsync(IList<object>? i_SelectedItems)
    {
        var sb = new StringBuilder(Entries.Count * 64);

        if (i_SelectedItems != null && i_SelectedItems.Count > 0)
        {
            var snapshot = new object[i_SelectedItems.Count];
            i_SelectedItems.CopyTo(snapshot, 0);

            foreach (object item in snapshot)
            {
                if (item is UiLogEntry e) { AppendEntryLine(sb, e); }
            }
        }
        else
        {
            foreach (var item in m_FilteredEntries)
            {
                if (item is UiLogEntry e) { AppendEntryLine(sb, e); }
            }
        }

        var data = new DataPackage();
        data.SetText(sb.ToString());
        Clipboard.SetContent(data);

        CopyButtonText = "Copied";
        await Task.Delay(900);

        int selectedCount = m_LastSelectedCount;
        DispatcherQueue? dq = m_DispatcherQueue;

        if (dq == null || dq.HasThreadAccess) { UpdateSelectionButtons(selectedCount, m_FilteredEntries.Count); }
        else { dq.TryEnqueue(() => { UpdateSelectionButtons(selectedCount, m_FilteredEntries.Count); }); }
    }

    // Clears selected rows (if any); otherwise clears all
    private void ExecuteClear(IList<object>? i_SelectedItems)
    {
        if (i_SelectedItems != null && i_SelectedItems.Count > 0)
        {
            var snapshot = new object[i_SelectedItems.Count];
            i_SelectedItems.CopyTo(snapshot, 0);

            foreach (object item in snapshot)
            {
                if (item is UiLogEntry e) { m_LogBuffer.Remove(e); }
            }

            RequestSelectionClear();
            return;
        }

        m_LogBuffer.Clear();
        RequestSelectionClear();
    }

    // Select all / deselect all visible rows
    private void ExecuteToggleSelectAll(ListView? i_ListView)
    {
        if (i_ListView == null) { return; }

        int total = m_FilteredEntries.Count;
        int selected = i_ListView.SelectedItems.Count;

        if (total > 0 && selected == total)
        {
            i_ListView.SelectedItems.Clear();
            UpdateSelectionButtons(0, total);
            return;
        }

        i_ListView.SelectedItems.Clear();

        // Add only LogEntry items (defensive)
        foreach (var item in m_FilteredEntries)
        {
            if (item is UiLogEntry)
            {
                i_ListView.SelectedItems.Add(item);
            }
        }

        UpdateSelectionButtons(i_ListView.SelectedItems.Count, total);
    }

    // Scroll once (page open)
    private void ScrollToBottom(ListView i_ListView)
    {
        int count = m_FilteredEntries.Count;
        if (count <= 0) { return; }

        object last = m_FilteredEntries[count - 1];
        m_DispatcherQueue?.TryEnqueue(() => { i_ListView.ScrollIntoView(last); });
    }

    // Updates button labels based on selection
    private void UpdateSelectionButtons(int i_SelectedCount, int i_TotalVisible)
    {
        ClearButtonText = i_SelectedCount > 0 ? "Clear selected" : "Clear all";
        SelectAllButtonText = (i_TotalVisible > 0 && i_SelectedCount == i_TotalVisible) ? "Deselect all" : "Select all";
        CopyButtonText = i_SelectedCount > 0 ? "Copy selected" : "Copy all";
    }

    // Appends a formatted log line into the builder
    private static void AppendEntryLine(StringBuilder i_Sb, UiLogEntry i_Entry)
    {
        i_Sb.Append(i_Entry.TimestampLocal.ToString("yyyy-MM-dd HH:mm:ss.fff"));
        i_Sb.Append(" [");
        i_Sb.Append(i_Entry.Level);
        i_Sb.Append("] ");
        i_Sb.AppendLine(i_Entry.Message);
    }

    // Opens the logs folder in Explorer
    private async Task ExecuteOpenLogFolderAsync()
    {
        try
        {
            StorageFolder folder = await StorageFolder.GetFolderFromPathAsync(LogFolderPath);
            await Launcher.LaunchFolderAsync(folder);
        }
        catch { }
    }

    // Called by the page after it loads to scroll once to bottom
    public void OnPageOpened(ListView? i_ListView)
    {
        if (i_ListView == null) { return; }
        m_DispatcherQueue = i_ListView.DispatcherQueue;
        ScrollToBottom(i_ListView);
    }

    // Called by the page when selection changes (so VM updates button text)
    public void OnSelectionChanged(int i_SelectedCount)
    {
        m_LastSelectedCount = i_SelectedCount;
        UpdateSelectionButtons(i_SelectedCount, m_FilteredEntries.Count);
    }

    // Requests the view to clear ListView selection and updates button texts accordingly
    private void RequestSelectionClear()
    {
        RequestClearSelection?.Invoke();
        UpdateSelectionButtons(0, m_FilteredEntries.Count);
        m_LastSelectedCount = 0;
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\ViewModels\Settings\SettingsViewModel.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.UI\ViewModels\Settings\SettingsViewModel.cs
using System;
using System.Diagnostics;
using System.IO;

using CommunityToolkit.Mvvm.Input;

using NavigationIntegrationSystem.UI.ViewModels.Base;

namespace NavigationIntegrationSystem.UI.ViewModels.Settings;

public sealed partial class SettingsViewModel : ViewModelBase
{
    #region Commands
    public IRelayCommand OpenRecordingsFolderCommand { get; }
    #endregion

    #region Constructors
    public SettingsViewModel()
    {
        OpenRecordingsFolderCommand = new RelayCommand(OnOpenRecordingsFolder);
    }
    #endregion

    #region Command Handlers
    // Opens the folder where recordings are stored, creating it if it doesn't exist
    private void OnOpenRecordingsFolder()
    {
        string path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Recordings");

        if (!Directory.Exists(path))
        {
            Directory.CreateDirectory(path);
        }

        try
        {
            Process.Start(new ProcessStartInfo
            {
                FileName = path,
                UseShellExecute = true,
                Verb = "open"
            });
        }
        catch (Exception)
        {
            // Fallback for environment issues
        }
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Controls\ShellHeaderControl.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<UserControl x:Class="NavigationIntegrationSystem.UI.Views.Controls.ShellHeaderControl" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:vm="using:NavigationIntegrationSystem.UI.ViewModels">

    <Grid x:Name="AppTitleBar" Height="32" Padding="12,0,12,0" Background="{ThemeResource LayerFillColorDefaultBrush}">

        <StackPanel HorizontalAlignment="Left" VerticalAlignment="Center" Orientation="Horizontal" Spacing="10">
            <Image Width="18" Height="18" Source="ms-appx:///Assets/Square44x44Logo.png" />
            <TextBlock VerticalAlignment="Center" FontSize="13" FontWeight="SemiBold" Text="Navigation Integration System" />
        </StackPanel>

        <Grid HorizontalAlignment="Center" VerticalAlignment="Center">
            <StackPanel Orientation="Horizontal" Spacing="8">
                <Ellipse Width="8" Height="8" Fill="Red" Visibility="{x:Bind ViewModel.IsRecording, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}" />
                <Button Padding="8,2" Command="{x:Bind ViewModel.ToggleRecordingCommand}" FontSize="12">
                    <StackPanel Orientation="Horizontal" Spacing="6">
                        <SymbolIcon Symbol="{x:Bind ViewModel.IsRecording, Mode=OneWay, Converter={StaticResource RecordingStatusToIconConverter}}" />
                        <TextBlock Text="{x:Bind ViewModel.IsRecording, Mode=OneWay, Converter={StaticResource RecordingStatusToTextConverter}}" />
                    </StackPanel>
                </Button>
            </StackPanel>
        </Grid>

    </Grid>
</UserControl>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Controls\ShellHeaderControl.xaml.cs
// ---------------------------------------------------------

// FILE: src\NavigationIntegrationSystem.UI\Views\Controls\ShellHeaderControl.xaml.cs
using Microsoft.UI.Xaml.Controls;

using NavigationIntegrationSystem.UI.ViewModels;

namespace NavigationIntegrationSystem.UI.Views.Controls;

public sealed partial class ShellHeaderControl : UserControl
{
    #region Properties
    // Exposes the internal Grid to be used as the custom title bar by the Window
    public Grid TitleBarElement => AppTitleBar;

    // Type-safe access to the ViewModel for x:Bind
    public MainViewModel ViewModel => (MainViewModel)DataContext;
    #endregion

    #region Constructors
    public ShellHeaderControl()
    {
        this.InitializeComponent();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\DevicesPage.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<Page x:Class="NavigationIntegrationSystem.UI.Views.Pages.DevicesPage" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:panes="using:NavigationIntegrationSystem.UI.Views.Panes" xmlns:vm="using:NavigationIntegrationSystem.UI.ViewModels.Devices.Cards" x:Name="RootPage" mc:Ignorable="d">

    <Grid Padding="16" RowSpacing="12">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <!--  Page header: title + Save devices config  -->
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="Auto" />
            </Grid.ColumnDefinitions>
            <TextBlock FontSize="28" FontWeight="SemiBold" Text="Devices" />
            <Button Grid.Column="1" Command="{x:Bind ViewModel.SaveDevicesConfigCommand}" IsEnabled="{x:Bind ViewModel.CanSaveDevicesConfig, Mode=OneWay}" Style="{ThemeResource AccentButtonStyle}">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <SymbolIcon Symbol="{x:Bind ViewModel.SaveButtonIcon, Mode=OneWay}" />
                    <TextBlock Text="{x:Bind ViewModel.SaveButtonText, Mode=OneWay}" />
                </StackPanel>
            </Button>
        </Grid>

        <!--  Main layout: devices list on the left + right pane for Settings/Inspect  -->
        <SplitView Grid.Row="1" DisplayMode="Overlay"
                   IsPaneOpen="{x:Bind ViewModel.IsPaneOpen, Mode=TwoWay}"
                   LightDismissOverlayMode="On" OpenPaneLength="520" PaneClosing="OnPaneClosing" PanePlacement="Right">

            <SplitView.Content>
                <!--  Devices list: each item is a card  -->
                <ListView ItemsSource="{x:Bind ViewModel.Devices, Mode=OneWay}" SelectionMode="None">
                    <!--  Remove default ListViewItem padding/margins so our card aligns perfectly  -->
                    <ListView.ItemContainerStyle>
                        <Style TargetType="ListViewItem">
                            <Setter Property="Padding" Value="0" />
                            <Setter Property="Margin" Value="0" />
                            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
                        </Style>
                    </ListView.ItemContainerStyle>

                    <ListView.ItemTemplate>
                        <DataTemplate x:DataType="vm:DeviceCardViewModel">
                            <!--  Device card  -->
                            <Border Margin="0,0,0,10" Padding="14"
                                    Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
                                    BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                                    BorderThickness="1" CornerRadius="12">
                                <Grid>
                                    <Grid.RowDefinitions>
                                        <RowDefinition Height="Auto" />
                                        <RowDefinition Height="Auto" />
                                        <RowDefinition Height="Auto" />
                                    </Grid.RowDefinitions>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*" />
                                        <ColumnDefinition Width="Auto" />
                                    </Grid.ColumnDefinitions>
                                    <!--  Device identity  -->
                                    <TextBlock FontSize="18" Text="{x:Bind DisplayName}" />

                                    <!--  Runtime status (Connected/Connecting/Disconnected/Error)  -->
                                    <TextBlock Grid.Column="1" HorizontalAlignment="Right" FontSize="12" FontWeight="SemiBold"
                                               Foreground="{x:Bind Status, Mode=OneWay, Converter={StaticResource DeviceStatusToBrushConverter}}"
                                               Text="{x:Bind Status, Mode=OneWay}" />

                                    <!--  Actions row  -->
                                    <StackPanel Grid.Row="1" Grid.ColumnSpan="2" Margin="0,12,0,0" Orientation="Horizontal" Spacing="10">
                                        <!--  Connect/Disconnect (text changes based on Status)  -->
                                        <Button Command="{x:Bind ToggleConnectCommand}" IsEnabled="{x:Bind CanToggleConnect, Mode=OneWay}">
                                            <StackPanel Orientation="Horizontal" Spacing="8">
                                                <SymbolIcon Symbol="Link" />
                                                <TextBlock Text="{x:Bind ConnectButtonText, Mode=OneWay}" />
                                            </StackPanel>
                                        </Button>

                                        <!--  Open Settings pane  -->
                                        <Button Command="{x:Bind OpenSettingsCommand}" Visibility="{x:Bind ShowSettingsInspect, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}">
                                            <StackPanel Orientation="Horizontal" Spacing="8">
                                                <SymbolIcon Symbol="Setting" />
                                                <TextBlock Text="Settings" />
                                            </StackPanel>
                                        </Button>

                                        <!--  Open Inspect pane  -->
                                        <Button Command="{x:Bind OpenInspectCommand}" Visibility="{x:Bind ShowSettingsInspect, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}">
                                            <StackPanel Orientation="Horizontal" Spacing="8">
                                                <SymbolIcon Symbol="Preview" />
                                                <TextBlock Text="Inspect" />
                                            </StackPanel>
                                        </Button>
                                    </StackPanel>

                                    <!--  Inline warning when settings changed but not saved  -->
                                    <StackPanel Grid.Row="2" Grid.ColumnSpan="2" Margin="0,8,0,0" Orientation="Horizontal" Spacing="8"
                                                Visibility="{x:Bind HasUnsavedSettings, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}">
                                        <FontIcon Margin="0,1,0,0" Glyph="&#xE7BA;" />
                                        <TextBlock Foreground="{ThemeResource SystemFillColorCautionBrush}" Text="Settings were changed but not saved" />
                                    </StackPanel>

                                    <!--  Show last error (only when not null/empty)  -->
                                    <!--  If you already have a StringNullOrEmptyToVisibilityConverter in App.xaml, keep it; otherwise remove this block  -->
                                    <TextBlock Grid.Row="2" Grid.ColumnSpan="2" Margin="0,8,0,0" Opacity="0.85"
                                               Text="{x:Bind LastError, Mode=OneWay}"
                                               Visibility="{x:Bind LastError, Mode=OneWay, Converter={StaticResource StringNullOrEmptyToVisibilityConverter}}" />
                                </Grid>
                            </Border>
                        </DataTemplate>
                    </ListView.ItemTemplate>
                </ListView>
            </SplitView.Content>

            <SplitView.Pane>
                <!--  Right pane: header + (Settings or Inspect) + footer actions  -->
                <Grid Padding="16" Background="{ThemeResource CardBackgroundFillColorDefaultBrush}" BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}" BorderThickness="1" CornerRadius="12">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="*" />
                        <RowDefinition Height="Auto" />
                    </Grid.RowDefinitions>

                    <!--  Pane header: selected device name  -->
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="Auto" />
                        </Grid.ColumnDefinitions>
                        <TextBlock FontSize="18" FontWeight="SemiBold" Text="{x:Bind ViewModel.SelectedDevice.DisplayName, Mode=OneWay}" />
                    </Grid>

                    <!--  Divider  -->
                    <Border Grid.Row="1" Height="1" Margin="0,12,0,12" Background="{ThemeResource CardStrokeColorDefaultBrush}" />

                    <!--  Pane content: Settings OR Inspect (visibility controlled by PaneMode converters)  -->
                    <Grid Grid.Row="2" Margin="0,0,0,12">
                        <panes:DeviceSettingsPaneView x:Name="DeviceSettingsPaneView" DataContext="{x:Bind ViewModel.CurrentSettingsPane, Mode=OneWay}" Visibility="{x:Bind ViewModel.PaneMode, Mode=OneWay, Converter={StaticResource PaneModeToSettingsVisibilityConverter}}" />
                        <panes:DeviceInspectPaneView ViewModel="{x:Bind ViewModel.SelectedDevice, Mode=OneWay}" Visibility="{x:Bind ViewModel.PaneMode, Mode=OneWay, Converter={StaticResource PaneModeToInspectVisibilityConverter}}" />
                    </Grid>

                    <!--  Pane footer: settings apply/save only when Settings is visible  -->
                    <Grid Grid.Row="3" VerticalAlignment="Bottom">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="Auto" />
                        </Grid.ColumnDefinitions>
                        <Button Grid.Column="1" Command="{x:Bind ViewModel.ApplySettingsCommand}" Content="Apply &amp; Save" Style="{ThemeResource AccentButtonStyle}" Visibility="{x:Bind ViewModel.PaneMode, Mode=OneWay, Converter={StaticResource PaneModeToSettingsVisibilityConverter}}" />
                    </Grid>
                </Grid>
            </SplitView.Pane>
        </SplitView>
    </Grid>
</Page>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\DevicesPage.xaml.cs
// ---------------------------------------------------------

using Microsoft.Extensions.DependencyInjection;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.UI.Enums;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Pages;

namespace NavigationIntegrationSystem.UI.Views.Pages;

// Displays fixed device cards and provides settings/inspect panes per device
public sealed partial class DevicesPage : Page
{
    #region Properties
    public DevicesViewModel ViewModel { get; }
    #endregion

    #region Ctors
    public DevicesPage()
    {
        InitializeComponent();
        ViewModel = ((App)Application.Current).Services.GetRequiredService<DevicesViewModel>();
    }
    #endregion

    #region Event Handlers
    // Intercepts light-dismiss close to allow unsaved-changes decision
    private async void OnPaneClosing(SplitView sender, SplitViewPaneClosingEventArgs args)
    {
        if (!ViewModel.ShouldConfirmPaneClose())
        {
            ViewModel.ClosePane();
            return;
        }

        args.Cancel = true;

        DialogCloseDecision decision = await ViewModel.ConfirmCloseSettingsAsync(sender.XamlRoot);

        if (decision == DialogCloseDecision.Cancel) { return; }

        ViewModel.ForceClosePaneAfterDecision(decision);
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\IntegrationPage.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<Page x:Class="NavigationIntegrationSystem.UI.Views.Pages.IntegrationPage" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:candidates="using:NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates" xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:layout="using:NavigationIntegrationSystem.UI.ViewModels.Integration.Layout" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="d">

    <Page.Resources>
        <!--  Numeric candidate: RadioButton + Text  -->
        <DataTemplate x:Key="NumericCandidateTemplate" x:DataType="candidates:NumericSourceCandidateViewModel">
            <Grid Width="150">
                <RadioButton VerticalAlignment="Center" Click="OnSourceRadioButtonClicked" IsChecked="{x:Bind IsSelected, Mode=OneWay}">
                    <RadioButton.Content>
                        <TextBlock VerticalAlignment="Center" FontFamily="Consolas" FontSize="14" Text="{x:Bind DisplayText, Mode=OneWay}" />
                    </RadioButton.Content>
                </RadioButton>
            </Grid>
        </DataTemplate>

        <!--  Manual candidate: RadioButton + TextBox (enabled only when selected)  -->
        <DataTemplate x:Key="ManualCandidateTemplate" x:DataType="candidates:ManualSourceCandidateViewModel">
            <Grid Width="150">
                <Grid VerticalAlignment="Center">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="24" />
                        <ColumnDefinition Width="100" />
                    </Grid.ColumnDefinitions>

                    <RadioButton Grid.Column="0" Width="32" Padding="0" HorizontalAlignment="Left" VerticalAlignment="Center"
                                 Click="OnSourceRadioButtonClicked"
                                 IsChecked="{x:Bind IsSelected, Mode=OneWay}" />

                    <TextBox Grid.Column="1" Margin="4,0,0,0" FontFamily="Consolas" FontSize="14"
                             IsEnabled="{x:Bind IsSelected, Mode=OneWay}"
                             PlaceholderText="Value"
                             Text="{x:Bind Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                </Grid>
            </Grid>
        </DataTemplate>

        <!--  Chooses template by candidate type  -->
        <candidates:IntegrationCandidateTemplateSelector x:Key="IntegrationCandidateTemplateSelector" ManualTemplate="{StaticResource ManualCandidateTemplate}" NumericTemplate="{StaticResource NumericCandidateTemplate}" />
    </Page.Resources>

    <!--  Page layout: Title + Integration surface  -->
    <Grid Padding="16" RowSpacing="12">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <!--  Title  -->
        <TextBlock Grid.Row="0" FontSize="28" FontWeight="SemiBold" Text="Integration" />

        <!--  Main integration surface  -->
        <Border Grid.Row="1" Padding="20"
                Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
                BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                BorderThickness="1" CornerRadius="12">
            <Grid RowSpacing="20">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="*" />
                </Grid.RowDefinitions>

                <!--  Active sources selector (visibility + apply-to-all)  -->
                <Grid Grid.Row="0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>

                    <TextBlock Grid.Column="0" VerticalAlignment="Center" FontWeight="SemiBold" Text="Active Sources (Max 3):" />

                    <!--  Scrollable chips: connected sources only  -->
                    <ScrollViewer Grid.Column="1" HorizontalAlignment="Right" HorizontalScrollBarVisibility="Auto" HorizontalScrollMode="Enabled" VerticalScrollBarVisibility="Disabled">
                        <ItemsControl ItemsSource="{x:Bind ViewModel.ConnectedDevices, Mode=OneWay}">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel Orientation="Horizontal" Spacing="12" />
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>

                            <ItemsControl.ItemTemplate>
                                <DataTemplate x:DataType="layout:IntegrationDeviceOptionViewModel">
                                    <Border Padding="8,4" Background="{ThemeResource ControlFillColorDefaultBrush}" BorderBrush="{ThemeResource ControlStrokeColorDefaultBrush}" BorderThickness="1" CornerRadius="8">
                                        <StackPanel Orientation="Horizontal" Spacing="8">
                                            <CheckBox VerticalAlignment="Center" Content="{x:Bind DisplayName}" FontWeight="Bold" IsChecked="{x:Bind IsVisible, Mode=TwoWay}" />
                                            <Rectangle Width="1" Height="24" Fill="{ThemeResource DividerStrokeColorDefaultBrush}" />
                                            <Button Padding="4,4"
                                                    Background="{ThemeResource SystemAccentColor}"
                                                    Command="{x:Bind ApplyToAllFieldsCommand}"
                                                    Content="Apply to All" FontSize="12" Foreground="White"
                                                    IsEnabled="{x:Bind IsVisible, Mode=OneWay}"
                                                    Style="{StaticResource AccentButtonStyle}" />
                                        </StackPanel>
                                    </Border>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>

                <!--  Divider  -->
                <Rectangle Grid.Row="1" Height="1" Fill="{ThemeResource DividerStrokeColorDefaultBrush}" />

                <!--  Parameters table  -->
                <ListView Grid.Row="2" ItemsSource="{x:Bind ViewModel.Rows, Mode=OneWay}" SelectionMode="None">
                    <ListView.ItemsPanel>
                        <ItemsPanelTemplate>
                            <StackPanel />
                        </ItemsPanelTemplate>
                    </ListView.ItemsPanel>

                    <!--  Header row  -->
                    <ListView.Header>
                        <Grid Margin="0,0,0,12">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="150" />
                                <ColumnDefinition Width="150" />
                                <ColumnDefinition Width="70" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>

                            <TextBlock Grid.Column="0" Margin="16,0" FontWeight="SemiBold" Opacity="0.6" Text="Parameter" />
                            <TextBlock Grid.Column="1" HorizontalAlignment="Center" FontWeight="Bold" Foreground="{ThemeResource SystemAccentColorLight2}" Text="Integrated Output" />

                            <!--  Spacer  -->
                            <Grid Grid.Column="2" />

                            <!--  Source columns (visible-only)  -->
                            <ItemsControl Grid.Column="3" ItemsSource="{x:Bind ViewModel.ConnectedDevices, Mode=OneWay}">
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <StackPanel Orientation="Horizontal" />
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>

                                <ItemsControl.ItemTemplate>
                                    <DataTemplate x:DataType="layout:IntegrationDeviceOptionViewModel">
                                        <Grid Width="150" Visibility="{x:Bind IsVisible, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}">
                                            <TextBlock FontWeight="SemiBold" Opacity="0.6" Text="{x:Bind DisplayName}" />
                                        </Grid>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </Grid>
                    </ListView.Header>

                    <!--  Make each row stretch full width  -->
                    <ListView.ItemContainerStyle>
                        <Style TargetType="ListViewItem">
                            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
                            <Setter Property="Padding" Value="0" />
                        </Style>
                    </ListView.ItemContainerStyle>

                    <!--  One row per integration field  -->
                    <ListView.ItemTemplate>
                        <DataTemplate x:DataType="layout:IntegrationFieldRowViewModel">
                            <Border Margin="0,0,0,10" Background="{ThemeResource CardBackgroundFillColorDefaultBrush}" BorderBrush="{ThemeResource DividerStrokeColorDefaultBrush}" BorderThickness="1" CornerRadius="8">
                                <Grid MinHeight="50">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="150" />
                                        <ColumnDefinition Width="150" />
                                        <ColumnDefinition Width="70" />
                                        <ColumnDefinition Width="*" />
                                    </Grid.ColumnDefinitions>

                                    <!--  Field name + unit  -->
                                    <StackPanel Grid.Column="0" Margin="16,0" VerticalAlignment="Center">
                                        <TextBlock FontSize="15" FontWeight="Bold" Text="{x:Bind FieldName}" />
                                        <TextBlock FontSize="11" Opacity="0.5" Text="{x:Bind Unit}" />
                                    </StackPanel>

                                    <!--  Integrated output  -->
                                    <Grid Grid.Column="1">
                                        <Border Background="{ThemeResource SystemAccentColor}" CornerRadius="6" Opacity="0.1" />
                                        <TextBlock HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="Consolas" FontSize="20" FontWeight="Bold"
                                                   Foreground="{ThemeResource SystemAccentColorLight3}"
                                                   Text="{x:Bind SelectedValueText, Mode=OneWay}" />
                                    </Grid>

                                    <!--  Spacer  -->
                                    <Grid Grid.Column="2" />

                                    <!--  Per-source candidates  -->
                                    <Grid Grid.Column="3" Visibility="{x:Bind IsCalculated, Mode=OneWay, Converter={StaticResource InverseBoolToVisibilityConverter}}">
                                        <ItemsControl ItemTemplateSelector="{StaticResource IntegrationCandidateTemplateSelector}" ItemsSource="{x:Bind VisibleSources, Mode=OneWay}">
                                            <ItemsControl.ItemsPanel>
                                                <ItemsPanelTemplate>
                                                    <StackPanel Orientation="Horizontal" />
                                                </ItemsPanelTemplate>
                                            </ItemsControl.ItemsPanel>
                                        </ItemsControl>
                                    </Grid>

                                    <TextBlock Grid.Column="3" VerticalAlignment="Center" FontStyle="Italic" Opacity="0.5" Text="Automatically calculated from velocity components"
                                               Visibility="{x:Bind IsCalculated, Mode=OneWay, Converter={StaticResource BoolToVisibilityConverter}}" />
                                </Grid>
                            </Border>
                        </DataTemplate>
                    </ListView.ItemTemplate>
                </ListView>
            </Grid>
        </Border>
    </Grid>
</Page>


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\IntegrationPage.xaml.cs
// ---------------------------------------------------------

using Microsoft.Extensions.DependencyInjection;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Media;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Candidates;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Layout;
using NavigationIntegrationSystem.UI.ViewModels.Integration.Pages;

namespace NavigationIntegrationSystem.UI.Views.Pages;

// Displays the Integration grid and binds it to the IntegrationViewModel
public sealed partial class IntegrationPage : Page
{
    #region Properties
    public IntegrationViewModel ViewModel { get; }
    #endregion

    #region Constructors
    public IntegrationPage()
    {
        InitializeComponent();
        ViewModel = ((App)Application.Current).Services.GetRequiredService<IntegrationViewModel>();
        ViewModel.Initialize(Microsoft.UI.Dispatching.DispatcherQueue.GetForCurrentThread());

        this.Unloaded += (s, e) => ViewModel.Deinitialize();
    }
    #endregion

    #region Event Handlers
    // Routes candidate selection click to the owning row
    private void OnSourceRadioButtonClicked(object i_Sender, RoutedEventArgs i_E)
    {
        if (i_Sender is not RadioButton radioButton) { return; }
        if (radioButton.DataContext is not IntegrationSourceCandidateViewModel src) { return; }

        DependencyObject current = radioButton;
        while (current != null && current is not ListViewItem) { current = VisualTreeHelper.GetParent(current); }
        if (current is not ListViewItem listViewItem) { return; }
        if (listViewItem.Content is not IntegrationFieldRowViewModel row) { return; }

        row.SelectSource(src);
    }
    #endregion
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\LogsPage.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<Page x:Class="NavigationIntegrationSystem.UI.Views.Pages.LogsPage" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:logging="using:NavigationIntegrationSystem.UI.Services.Logging"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="d">

    <Grid Padding="16" KeyboardAcceleratorPlacementMode="Hidden" RowSpacing="12">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <!--  Keyboard Accelerators  -->
        <Grid.KeyboardAccelerators>
            <KeyboardAccelerator Key="C" Invoked="OnCopyAcceleratorInvoked" Modifiers="Control" />
            <KeyboardAccelerator Key="A" Invoked="OnSelectAllAcceleratorInvoked" Modifiers="Control" />
            <KeyboardAccelerator Key="Delete" Invoked="OnDeleteAcceleratorInvoked" />
            <KeyboardAccelerator Key="Escape" Invoked="OnEscapeAcceleratorInvoked" />
        </Grid.KeyboardAccelerators>

        <!--  Header  -->
        <TextBlock FontSize="28" FontWeight="SemiBold" Text="Logs" />

        <!--  Filters + Actions (same row)  -->
        <Grid Grid.Row="1" VerticalAlignment="Center" ColumnSpacing="10">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="360" />
                <ColumnDefinition Width="80" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="120" />
                <ColumnDefinition Width="120" />
                <ColumnDefinition Width="120" />
            </Grid.ColumnDefinitions>
            <!--  Left: filters  -->
            <TextBox Grid.Column="0" Width="360" PlaceholderText="Search..." Text="{x:Bind ViewModel.SearchText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
            <ComboBox Grid.Column="1" Width="80" SelectedValue="{x:Bind ViewModel.SelectedLevel, Mode=TwoWay}" SelectedValuePath="Content">
                <ComboBoxItem Content="All" />
                <ComboBoxItem Content="DEBUG" />
                <ComboBoxItem Content="INFO" />
                <ComboBoxItem Content="WARN" />
                <ComboBoxItem Content="ERROR" />
            </ComboBox>

            <!--  Column 3 is the flexible spacer (*)  -->

            <!--  Right: actions  -->
            <Button Grid.Column="3" Width="120" Command="{x:Bind ViewModel.CopyCommand}" CommandParameter="{x:Bind ViewModel.SelectedItems, Mode=OneWay}" Content="{x:Bind ViewModel.CopyButtonText, Mode=OneWay}" />
            <Button Grid.Column="4" Width="120" Command="{x:Bind ViewModel.ClearCommand}" CommandParameter="{x:Bind ViewModel.SelectedItems, Mode=OneWay}" Content="{x:Bind ViewModel.ClearButtonText, Mode=OneWay}" />
            <Button Grid.Column="5" Width="120" Command="{x:Bind ViewModel.ToggleSelectAllCommand}" CommandParameter="{Binding ElementName=LogsList}" Content="{x:Bind ViewModel.SelectAllButtonText}" />
        </Grid>

        <!--  Log list container  -->
        <Border Grid.Row="2" Background="{ThemeResource CardBackgroundFillColorDefaultBrush}" BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}" BorderThickness="1" CornerRadius="12">
            <ListView x:Name="LogsList" Padding="8" ItemsSource="{x:Bind ViewModel.FilteredEntries, Mode=OneWay}" SelectionChanged="OnLogsSelectionChanged" SelectionMode="Multiple">
                <!--  Log entry template  -->
                <ListView.ItemTemplate>
                    <DataTemplate x:DataType="logging:UiLogEntry">
                        <Grid Padding="8" VerticalAlignment="Center" ColumnSpacing="16">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto" />
                                <ColumnDefinition Width="Auto" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>
                            <TextBlock Grid.Column="0" VerticalAlignment="Center" FontFamily="Consolas" Opacity="0.75" Text="{x:Bind TimestampText}" />
                            <TextBlock Grid.Column="1" VerticalAlignment="Center" FontFamily="Consolas" FontWeight="SemiBold"
                                       Foreground="{x:Bind Level, Converter={StaticResource LogLevelToBrushConverter}}"
                                       Text="{x:Bind Level}" />
                            <TextBlock Grid.Column="2" VerticalAlignment="Center" Text="{x:Bind Message}" TextWrapping="WrapWholeWords" />

                            <Rectangle Grid.ColumnSpan="3" Height="1" VerticalAlignment="Bottom" Fill="{ThemeResource CardStrokeColorDefaultBrush}" Opacity="0.25" />
                        </Grid>
                    </DataTemplate>
                </ListView.ItemTemplate>
            </ListView>
        </Border>

        <!--  Footer  -->
        <Grid Grid.Row="3" VerticalAlignment="Center">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="Auto" />
            </Grid.ColumnDefinitions>
            <TextBlock VerticalAlignment="Center" Opacity="0.7" Text="{x:Bind ViewModel.LogFolderPath, Mode=OneWay}" />
            <HyperlinkButton Grid.Column="1" Command="{x:Bind ViewModel.OpenLogFolderCommand}" Content="Open logs folder" />
        </Grid>
    </Grid>
</Page>


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\LogsPage.xaml.cs
// ---------------------------------------------------------

using Microsoft.Extensions.DependencyInjection;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Input;
using NavigationIntegrationSystem.UI.ViewModels;
using System;

namespace NavigationIntegrationSystem.UI.Views.Pages;

// Shows the live log buffer with filtering and actions
public sealed partial class LogsPage : Page
{
    #region Private Fields
    private Action? m_RequestClearSelectionHandler;
    private bool m_IgnoreSelectionChanged;
    #endregion

    #region Properties
    public LogsViewModel ViewModel { get; }
    #endregion

    #region Ctors
    public LogsPage()
    {
        ViewModel = ((App)Application.Current).Services.GetRequiredService<LogsViewModel>();

        InitializeComponent();

        Loaded += OnLoaded;
        Unloaded += OnUnloaded;

        m_RequestClearSelectionHandler = () =>
        {
            m_IgnoreSelectionChanged = true;

            LogsList.SelectedItems?.Clear();
            ViewModel.SelectedItems = LogsList.SelectedItems;
            ViewModel.OnSelectionChanged(0);

            m_IgnoreSelectionChanged = false;
        };

        ViewModel.RequestClearSelection += m_RequestClearSelectionHandler;
    }
    #endregion

    #region Event Handlers
    // Scroll once when the page opens
    private void OnLoaded(object sender, RoutedEventArgs e)
    {
        ViewModel.OnPageOpened(LogsList);
    }

    // Detach event handlers to avoid memory leaks
    private void OnUnloaded(object sender, RoutedEventArgs e)
    {
        if (m_RequestClearSelectionHandler != null)
        {
            ViewModel.RequestClearSelection -= m_RequestClearSelectionHandler;
            m_RequestClearSelectionHandler = null;
        }
    }

    // Forward selection count changes to the VM so it can update button texts
    private void OnLogsSelectionChanged(object sender, SelectionChangedEventArgs e)
    {
        if (m_IgnoreSelectionChanged) { return; }

        ViewModel.SelectedItems = LogsList.SelectedItems;
        ViewModel.OnSelectionChanged(LogsList.SelectedItems.Count);
    }
    #endregion

    #region Keyboard Shortcuts
    // Handles Ctrl+C copy shortcut
    private async void OnCopyAcceleratorInvoked(KeyboardAccelerator sender, KeyboardAcceleratorInvokedEventArgs args)
    {
        args.Handled = true;
        await ViewModel.CopyCommand.ExecuteAsync(LogsList.SelectedItems);
    }

    // Handles Ctrl+A select/deselect all shortcut
    private void OnSelectAllAcceleratorInvoked(KeyboardAccelerator sender, KeyboardAcceleratorInvokedEventArgs args)
    {
        args.Handled = true;
        ViewModel.ToggleSelectAllCommand.Execute(LogsList);
    }

    // Handles Delete clear shortcut
    private void OnDeleteAcceleratorInvoked(KeyboardAccelerator sender, KeyboardAcceleratorInvokedEventArgs args)
    {
        args.Handled = true;
        ViewModel.ClearCommand.Execute(LogsList.SelectedItems);
    }

    // Handles Esc to clear selection shortcut
    private void OnEscapeAcceleratorInvoked(KeyboardAccelerator sender, KeyboardAcceleratorInvokedEventArgs args)
    {
        args.Handled = true;

        m_IgnoreSelectionChanged = true;

        LogsList.SelectedItems?.Clear();
        ViewModel.OnSelectionChanged(0);

        m_IgnoreSelectionChanged = false;
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\SettingsPage.xaml
// ---------------------------------------------------------

<Page x:Class="NavigationIntegrationSystem.UI.Views.Pages.SettingsPage" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <StackPanel Padding="40" Spacing="20">
        <TextBlock Style="{StaticResource TitleTextBlockStyle}" Text="Settings" />

        <StackPanel Spacing="10">
            <TextBlock Style="{StaticResource BodyStrongTextBlockStyle}" Text="Data Management" />
            <Button Command="{x:Bind ViewModel.OpenRecordingsFolderCommand}">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <SymbolIcon Symbol="Folder" />
                    <TextBlock Text="Open Recordings Folder" />
                </StackPanel>
            </Button>
            <TextBlock Foreground="Gray" Style="{StaticResource CaptionTextBlockStyle}" Text="Opens the directory containing .dat and .csv logs." />
        </StackPanel>
    </StackPanel>
</Page>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Pages\SettingsPage.xaml.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Controls;
using Microsoft.Extensions.DependencyInjection;
using NavigationIntegrationSystem.UI.ViewModels.Settings;

namespace NavigationIntegrationSystem.UI.Views.Pages;

public sealed partial class SettingsPage : Page
{
    #region Properties
    public SettingsViewModel ViewModel { get; }
    #endregion

    #region Constructors
    public SettingsPage()
    {
        InitializeComponent();

        ViewModel = ((App)Microsoft.UI.Xaml.Application.Current).Services.GetRequiredService<SettingsViewModel>();
    }
    #endregion
}

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Panes\DeviceInspectPaneView.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<UserControl x:Class="NavigationIntegrationSystem.UI.Views.Panes.DeviceInspectPaneView" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:local="using:NavigationIntegrationSystem.UI.Views.Panes"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:vm="using:NavigationIntegrationSystem.UI.ViewModels.Devices.Cards" mc:Ignorable="d">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <TextBlock Margin="0,0,0,8" Opacity="0.7" Text="Inspect (all fields)" />
        <ListView Grid.Row="1" ItemsSource="{x:Bind ViewModel.InspectFields, Mode=OneWay}">
            <ListView.ItemTemplate>
                <DataTemplate x:DataType="vm:InspectFieldViewModel">
                    <Grid Padding="0,4" ColumnSpacing="12">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="220" />
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="70" />
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="{x:Bind Name}" />
                        <TextBlock Grid.Column="1" Text="{x:Bind ValueText}" TextTrimming="CharacterEllipsis" />
                        <TextBlock Grid.Column="2" HorizontalAlignment="Right" Opacity="0.7" Text="{x:Bind Unit}" />
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>
    </Grid>
</UserControl>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Panes\DeviceInspectPaneView.xaml.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Cards;

namespace NavigationIntegrationSystem.UI.Views.Panes
{
    public sealed partial class DeviceInspectPaneView : UserControl
    {
        #region Properties
        public DeviceCardViewModel? ViewModel { get; set; }
        #endregion

        #region Constructors
        public DeviceInspectPaneView()
        {
            InitializeComponent();
        }
        #endregion
    }
}


// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Panes\DeviceSettingsPaneView.xaml
// ---------------------------------------------------------

<?xml version="1.0" encoding="utf-8" ?>
<UserControl x:Class="NavigationIntegrationSystem.UI.Views.Panes.DeviceSettingsPaneView" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d">

    <ScrollViewer HorizontalContentAlignment="Stretch" HorizontalScrollBarVisibility="Disabled">
        <StackPanel x:Name="RootPanel" HorizontalAlignment="Stretch" Spacing="14">

            <TextBlock FontSize="18" Text="Device Settings" />

            <!--  General  -->
            <Border Padding="12" BorderThickness="1" CornerRadius="10">
                <StackPanel HorizontalAlignment="Stretch" Spacing="10">
                    <Button x:Name="CommitFocusSink" Width="0" Height="0" IsTabStop="False" Opacity="0" />

                    <TextBlock FontSize="16" Opacity="0.8" Text="General" />

                    <Grid HorizontalAlignment="Stretch" ColumnSpacing="12" RowSpacing="10">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="160" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <TextBlock Grid.Row="0" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Connection kind" />
                        <ComboBox Grid.Row="0" Grid.Column="1" HorizontalAlignment="Stretch" ItemsSource="{Binding ConnectionKinds}" SelectedItem="{Binding Draft.ConnectionKind, Mode=TwoWay}" />

                        <TextBlock Grid.Row="1" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Auto reconnect" />
                        <CheckBox Grid.Row="1" Grid.Column="1" VerticalAlignment="Center" IsChecked="{Binding Draft.AutoReconnect, Mode=TwoWay}" />
                    </Grid>

                </StackPanel>
            </Border>

            <!--  UDP  -->
            <Border Padding="12" BorderThickness="1" CornerRadius="10" Visibility="{Binding Draft.ConnectionKind, Converter={StaticResource ConnectionKindToVisibilityConverter}, ConverterParameter=Udp}">
                <StackPanel HorizontalAlignment="Stretch" Spacing="10">
                    <TextBlock FontSize="16" Opacity="0.8" Text="UDP" />

                    <Grid HorizontalAlignment="Stretch" ColumnSpacing="12" RowSpacing="10">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="160" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <TextBlock Grid.Row="0" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Remote IP" />
                        <TextBox Grid.Row="0" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.UdpRemoteIp, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <TextBlock Grid.Row="1" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Remote port" />
                        <TextBox Grid.Row="1" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.UdpRemotePortText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <TextBlock Grid.Row="2" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Local IP" />
                        <TextBox Grid.Row="2" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.UdpLocalIp, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <TextBlock Grid.Row="3" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Local port" />
                        <TextBox Grid.Row="3" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.UdpLocalPortText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                    </Grid>
                </StackPanel>
            </Border>

            <!--  TCP  -->
            <Border Padding="12" BorderThickness="1" CornerRadius="10" Visibility="{Binding Draft.ConnectionKind, Converter={StaticResource ConnectionKindToVisibilityConverter}, ConverterParameter=Tcp}">
                <StackPanel HorizontalAlignment="Stretch" Spacing="10">
                    <TextBlock FontSize="16" Opacity="0.8" Text="TCP" />

                    <Grid HorizontalAlignment="Stretch" ColumnSpacing="12" RowSpacing="10">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="160" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <TextBlock Grid.Row="0" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Host" />
                        <TextBox Grid.Row="0" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.TcpHost, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <TextBlock Grid.Row="1" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Port" />
                        <TextBox Grid.Row="1" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.TcpPortText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                    </Grid>
                </StackPanel>
            </Border>

            <!--  Serial  -->
            <Border Padding="12" BorderThickness="1" CornerRadius="10" Visibility="{Binding Draft.ConnectionKind, Converter={StaticResource ConnectionKindToVisibilityConverter}, ConverterParameter=Serial}">
                <StackPanel HorizontalAlignment="Stretch" Spacing="10">
                    <TextBlock FontSize="16" Opacity="0.8" Text="Serial" />

                    <Grid HorizontalAlignment="Stretch" ColumnSpacing="12" RowSpacing="10">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="160" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <TextBlock Grid.Row="0" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Line kind" />
                        <ComboBox Grid.Row="0" Grid.Column="1" HorizontalAlignment="Stretch" ItemsSource="{Binding SerialLineKinds}" SelectedItem="{Binding Draft.SerialLineKind, Mode=TwoWay}" />

                        <TextBlock Grid.Row="1" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="COM port" />
                        <TextBox Grid.Row="1" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.SerialComPort, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <TextBlock Grid.Row="2" Grid.Column="0" VerticalAlignment="Center" Opacity="0.7" Text="Baud rate" />
                        <TextBox Grid.Row="2" Grid.Column="1" HorizontalAlignment="Stretch" Text="{Binding Draft.SerialBaudRateText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                    </Grid>
                </StackPanel>
            </Border>

        </StackPanel>
    </ScrollViewer>
</UserControl>

// ---------------------------------------------------------
// FILE: .\src\NavigationIntegrationSystem.UI\Views\Panes\DeviceSettingsPaneView.xaml.cs
// ---------------------------------------------------------

using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using NavigationIntegrationSystem.UI.ViewModels.Devices.Panes;

namespace NavigationIntegrationSystem.UI.Views.Panes;

// Settings pane view for a selected device
public sealed partial class DeviceSettingsPaneView : UserControl
{
    #region Constructors
    public DeviceSettingsPaneView()
    {
        InitializeComponent();
        DataContextChanged += OnDataContextChanged;
    }
    #endregion

    #region Functions
    // Updates ViewModel with current XamlRoot when DataContext changes
    private void OnDataContextChanged(FrameworkElement sender, DataContextChangedEventArgs args)
    {
        if (args.NewValue is DeviceSettingsPaneViewModel vm) { vm.SetXamlRoot(XamlRoot); }
    }
    #endregion
}

